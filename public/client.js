/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/client.ts":
/*!***********************!*\
  !*** ./app/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enemies/chaser */ \"./app/enemies/chaser.ts\");\n/* harmony import */ var app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/circler */ \"./app/enemies/circler.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_initialize__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/initialize */ \"./app/initialize.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst testDiscs = [\r\n    { x: 500, y: 500, radius: 500, links: [] },\r\n    { x: 1200, y: 1200, radius: 800, links: [] },\r\n    { x: 500, y: -200, radius: 500, links: [] },\r\n];\r\nlet state = {\r\n    fieldTime: 0,\r\n    hero: {\r\n        level: 0,\r\n        experience: 0,\r\n        life: 20,\r\n        maxLife: 20,\r\n        speed: 100,\r\n        armor: 1,\r\n        damage: 20,\r\n        attacksPerSecond: 2,\r\n        attackCooldown: 0,\r\n        x: 500,\r\n        y: 500,\r\n        radius: 15,\r\n        theta: 0,\r\n    },\r\n    heroBullets: [],\r\n    enemies: [],\r\n    enemyBullets: [],\r\n    activeDiscs: testDiscs,\r\n    visibleDiscs: testDiscs,\r\n    gameHasBeenInitialized: false,\r\n    paused: false,\r\n    keyboard: {\r\n        gameKeyValues: [],\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n    },\r\n};\r\n// @ts-ignore\r\nwindow['state'] = state;\r\nfunction getState() {\r\n    return state;\r\n}\r\nfunction doCirclesIntersect(circleA, circleB) {\r\n    const radius = circleA.radius + circleB.radius;\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    return dx * dx + dy * dy < radius * radius;\r\n}\r\nfunction update() {\r\n    const state = getState();\r\n    if (!state.gameHasBeenInitialized) {\r\n        (0,app_initialize__WEBPACK_IMPORTED_MODULE_14__.initializeGame)(state);\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.startDungeon)(state, (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_6__.createTreeDungeon)(Math.random(), 4000, 0));\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_4__.renderMinimap)(state.activeDiscs);\r\n    }\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__.updateKeyboardState)(state);\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.MENU)) {\r\n        state.paused = !state.paused;\r\n    }\r\n    if (state.paused) {\r\n        return;\r\n    }\r\n    state.fieldTime += app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    if (state.hero.life <= 0) {\r\n        return;\r\n    }\r\n    let dx = 0, dy = 0;\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.UP)) {\r\n        dy--;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.DOWN)) {\r\n        dy++;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.LEFT)) {\r\n        dx--;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_11__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_13__.GAME_KEY.RIGHT)) {\r\n        dx++;\r\n    }\r\n    const m = Math.sqrt(dx * dx + dy * dy);\r\n    if (m > 1) {\r\n        dx /= m;\r\n        dy /= m;\r\n    }\r\n    updateEnemies(state);\r\n    updateHeroBullets(state);\r\n    updateEnemyBullets(state);\r\n    const speed = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__.isRightMouseDown)() ? state.hero.speed : 1.5 * state.hero.speed;\r\n    state.hero.x += dx * speed / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    state.hero.y += dy * speed / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n    assignToDisc(state.hero, state.activeDiscs);\r\n    constrainToDisc(state.hero, state.hero.disc);\r\n    if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__.isMouseDown)() && state.hero.attackCooldown <= state.fieldTime) {\r\n        state.hero.attackCooldown = state.fieldTime + 1000 / state.hero.attacksPerSecond;\r\n        const [x, y] = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_10__.getMousePosition)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__.mainCanvas, app_constants__WEBPACK_IMPORTED_MODULE_13__.CANVAS_SCALE);\r\n        let dx = x - app_constants__WEBPACK_IMPORTED_MODULE_13__.CANVAS_WIDTH / 2, dy = y - app_constants__WEBPACK_IMPORTED_MODULE_13__.CANVAS_HEIGHT / 2;\r\n        const m = Math.sqrt(dx * dx + dy * dy);\r\n        if (m > 1) {\r\n            dx /= m;\r\n            dy /= m;\r\n        }\r\n        state.heroBullets.push({\r\n            x: state.hero.x + dx * state.hero.radius,\r\n            y: state.hero.y + dy * state.hero.radius,\r\n            damage: state.hero.damage,\r\n            radius: 5,\r\n            vx: dx * 200,\r\n            vy: dy * 200,\r\n            expirationTime: state.fieldTime + 1000,\r\n        });\r\n    }\r\n    if (state.enemies.filter(e => !e.master).length < 0) {\r\n        for (const disc of state.activeDiscs) {\r\n            if (disc === state.hero.disc) {\r\n                continue;\r\n            }\r\n            if (Math.random() < 0.05) {\r\n                const definition = app_utils_Random__WEBPACK_IMPORTED_MODULE_12__[\"default\"].element([app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__.turret, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__.chaser, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__.chaser, app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__.circler, app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__.circler, app_enemies_lord__WEBPACK_IMPORTED_MODULE_2__.lord]);\r\n                const radius = definition === app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__.turret ? disc.radius / 8 : disc.radius / 4;\r\n                const theta = Math.random() * 2 * Math.PI;\r\n                let level = Math.floor(state.hero.level / 2);\r\n                while (Math.random() < 0.5 && level < state.hero.level) {\r\n                    level++;\r\n                }\r\n                const enemy = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(disc.x + radius * Math.cos(theta), disc.y + radius * Math.sin(theta), definition, level);\r\n                state.enemies.push(enemy);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction updateEnemies(state) {\r\n    for (const enemy of state.enemies) {\r\n        enemy.definition.update(state, enemy);\r\n        assignToDisc(enemy, state.activeDiscs);\r\n        constrainToDisc(enemy, enemy.disc);\r\n    }\r\n}\r\nfunction updateHeroBullets(state) {\r\n    var _a;\r\n    const activeBullets = state.heroBullets.filter(b => b.expirationTime >= state.fieldTime);\r\n    state.heroBullets = [];\r\n    for (const bullet of activeBullets) {\r\n        bullet.x += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        bullet.y += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        let bulletAbsorbed = false;\r\n        for (const enemy of state.enemies) {\r\n            if (doCirclesIntersect(enemy, bullet)) {\r\n                enemy.life -= bullet.damage;\r\n                if (enemy.life <= 0) {\r\n                    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_9__.gainExperience)(state, Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_13__.BASE_XP * Math.pow(1.2, enemy.level) * ((_a = enemy.definition.experienceFactor) !== null && _a !== void 0 ? _a : 1)));\r\n                }\r\n                else {\r\n                    // Shots are not absorbed by defeated enemies.\r\n                    bulletAbsorbed = true;\r\n                }\r\n            }\r\n        }\r\n        if (!bulletAbsorbed) {\r\n            state.heroBullets.push(bullet);\r\n        }\r\n    }\r\n    state.enemies = state.enemies.filter(e => e.life > 0);\r\n}\r\nfunction updateEnemyBullets(state) {\r\n    const activeBullets = state.enemyBullets.filter(b => b.expirationTime >= state.fieldTime);\r\n    state.enemyBullets = [];\r\n    for (const bullet of activeBullets) {\r\n        bullet.x += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        bullet.y += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH;\r\n        let hitTarget = false;\r\n        if (doCirclesIntersect(state.hero, bullet)) {\r\n            hitTarget = true;\r\n            state.hero.life -= bullet.damage;\r\n            if (state.hero.life <= 0) {\r\n                state.hero.life = 0;\r\n                // game over.\r\n            }\r\n        }\r\n        if (!hitTarget) {\r\n            state.enemyBullets.push(bullet);\r\n        }\r\n    }\r\n    state.enemies = state.enemies.filter(e => e.life > 0);\r\n}\r\nfunction assignToDisc(geometry, discs) {\r\n    geometry.disc = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_8__.findClosestDisc)(geometry, discs);\r\n}\r\nfunction constrainToDisc(geometry, disc) {\r\n    if (!disc) {\r\n        return;\r\n    }\r\n    const dx = geometry.x - disc.x, dy = geometry.y - disc.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 > disc.radius * disc.radius) {\r\n        const m = Math.sqrt(distance2);\r\n        geometry.x = disc.x + disc.radius * dx / m;\r\n        geometry.y = disc.y + disc.radius * dy / m;\r\n    }\r\n}\r\nfunction renderLoop() {\r\n    try {\r\n        window.requestAnimationFrame(renderLoop);\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_4__.render)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_5__.mainContext, getState());\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        debugger;\r\n    }\r\n}\r\nrenderLoop();\r\nsetInterval(update, app_constants__WEBPACK_IMPORTED_MODULE_13__.FRAME_LENGTH);\r\n\n\n//# sourceURL=webpack://alttp/./app/client.ts?");

/***/ }),

/***/ "./app/constants.ts":
/*!**************************!*\
  !*** ./app/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_XP: () => (/* binding */ BASE_XP),\n/* harmony export */   CANVAS_HEIGHT: () => (/* binding */ CANVAS_HEIGHT),\n/* harmony export */   CANVAS_SCALE: () => (/* binding */ CANVAS_SCALE),\n/* harmony export */   CANVAS_WIDTH: () => (/* binding */ CANVAS_WIDTH),\n/* harmony export */   FRAME_LENGTH: () => (/* binding */ FRAME_LENGTH),\n/* harmony export */   GAME_KEY: () => (/* binding */ GAME_KEY),\n/* harmony export */   SIGHT_RADIUS: () => (/* binding */ SIGHT_RADIUS)\n/* harmony export */ });\nconst FRAME_LENGTH = 20;\r\nconst CANVAS_WIDTH = 800;\r\nconst CANVAS_HEIGHT = 800;\r\nconst CANVAS_SCALE = 1;\r\nconst SIGHT_RADIUS = 400;\r\nconst GAME_KEY = {\r\n    MENU: 0,\r\n    UP: 1,\r\n    DOWN: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    RUN: 5,\r\n};\r\nconst BASE_XP = 10;\r\n\n\n//# sourceURL=webpack://alttp/./app/constants.ts?");

/***/ }),

/***/ "./app/enemies/chaser.ts":
/*!*******************************!*\
  !*** ./app/enemies/chaser.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chaser: () => (/* binding */ chaser)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst chaser = {\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n    },\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta), 1000);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/chaser.ts?");

/***/ }),

/***/ "./app/enemies/circler.ts":
/*!********************************!*\
  !*** ./app/enemies/circler.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circler: () => (/* binding */ circler)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst circler = {\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        attacksPerSecond: 2,\r\n    },\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 200;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        let targetTheta = enemy.theta;\r\n        if (distance2 < aggroRadius * aggroRadius) {\r\n            // Face the player, to shoot at them and circle them.\r\n            targetTheta = Math.atan2(y, x);\r\n            if (distance2 > 100 * 100) {\r\n                targetTheta -= Math.PI / 12;\r\n            }\r\n        }\r\n        else {\r\n            // Face the disc to shoot around it and circle it.\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            targetTheta = Math.atan2(y, x);\r\n            // Curve towards the center of the disc when too far out.\r\n            if (distance2 > enemy.disc.radius * enemy.disc.radius / 4) {\r\n                targetTheta -= Math.PI / 12;\r\n            }\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, targetTheta);\r\n        // Note this enemy moves sideways.\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta + Math.PI / 2) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta + Math.PI / 2) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta), 1000);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta + Math.PI), 100 * Math.sin(enemy.theta + Math.PI), 1000);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 10 * Math.cos(enemy.theta),\r\n            y: enemy.y + 10 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 10 * Math.cos(enemy.theta + Math.PI),\r\n            y: enemy.y + 10 * Math.sin(enemy.theta + Math.PI),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/circler.ts?");

/***/ }),

/***/ "./app/enemies/lord.ts":
/*!*****************************!*\
  !*** ./app/enemies/lord.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lord: () => (/* binding */ lord),\n/* harmony export */   lordsMinion: () => (/* binding */ lordsMinion)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst lord = {\r\n    statFactors: {\r\n        maxLife: 3,\r\n        damage: 1,\r\n        attacksPerSecond: 0.4,\r\n        speed: 0.4,\r\n    },\r\n    experienceFactor: 5,\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.minions = enemy.minions.filter(m => m.life > 0);\r\n        if (enemy.attackCooldown <= state.fieldTime && enemy.minions.length < 5) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (const theta of [enemy.theta + Math.PI / 2, enemy.theta - Math.PI / 2]) {\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), lordsMinion, enemy.level);\r\n                minion.theta = theta;\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n                state.enemies.push(minion);\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\nfunction chaseTarget(state, enemy, target) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n}\r\nconst lordsMinion = {\r\n    statFactors: {\r\n        maxLife: 0.5,\r\n        damage: 0.5,\r\n        attacksPerSecond: 0.5,\r\n    },\r\n    experienceFactor: 0.1,\r\n    radius: 15,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const master = enemy.master && enemy.master.life > 0 ? enemy.master : undefined;\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 <= aggroRadius * aggroRadius) {\r\n            // Leash back to master for a bit after attacking.\r\n            if (master && enemy.attackCooldown - state.fieldTime > 400) {\r\n                // Enemy moves in its current direction unless it gets too far from the master.\r\n                const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, master);\r\n                if (distance2 >= 300 * 300) {\r\n                    chaseTarget(state, enemy, master);\r\n                }\r\n            }\r\n            else {\r\n                // Chase the player when it can attack soon.\r\n                chaseTarget(state, enemy, state.hero);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta), 1000);\r\n            }\r\n        }\r\n        else if (master) {\r\n            // Enemy moves in its current direction unless it gets too far from the master.\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, master);\r\n            if (distance2 >= 200 * 200) {\r\n                chaseTarget(state, enemy, master);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 12 * Math.cos(enemy.theta),\r\n            y: enemy.y + 12 * Math.sin(enemy.theta),\r\n            radius: 2,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 2,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/lord.ts?");

/***/ }),

/***/ "./app/enemies/turret.ts":
/*!*******************************!*\
  !*** ./app/enemies/turret.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   turret: () => (/* binding */ turret)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\nconst turret = {\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n    },\r\n    experienceFactor: 2,\r\n    radius: 25,\r\n    update(state, enemy) {\r\n        const aggroRadius = 400;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            enemy.theta += 0.01;\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (let i = 0; i < 3; i++) {\r\n                const theta = enemy.theta - Math.PI / 6 + Math.PI / 6 * i;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_1__.shootEnemyBullet)(state, enemy, 100 * Math.cos(theta), 100 * Math.sin(theta), 2000);\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 20,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 15,\r\n        }, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/turret.ts?");

/***/ }),

/***/ "./app/initialize.ts":
/*!***************************!*\
  !*** ./app/initialize.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeGame: () => (/* binding */ initializeGame)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n\r\n\r\n\r\nfunction initializeGame(state) {\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.bindMouseListeners)();\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.addContextMenuListeners)();\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.addKeyboardListeners)();\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-loading').style.display = 'none';\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-gameContent').style.display = '';\r\n    state.gameHasBeenInitialized = true;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/initialize.ts?");

/***/ }),

/***/ "./app/render/renderGame.ts":
/*!**********************************!*\
  !*** ./app/render/renderGame.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fillCircle: () => (/* binding */ fillCircle),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   renderMinimap: () => (/* binding */ renderMinimap)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n\r\n\r\n\r\nconst minimapSize = 500;\r\nconst smallMapRect = { x: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 155, y: 5, w: 150, h: 150 };\r\nconst largeMapRect = { x: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 405, y: 5, w: 400, h: 400 };\r\nconst [mapCanvas, mapContext] = (0,app_utils_canvas__WEBPACK_IMPORTED_MODULE_1__.createCanvasAndContext)(minimapSize, minimapSize);\r\nconst mapScale = 20;\r\nfunction renderMinimap(discs) {\r\n    mapContext.fillStyle = '#000';\r\n    mapContext.fillRect(0, 0, minimapSize, minimapSize);\r\n    mapContext.save();\r\n    mapContext.translate(minimapSize / 2, minimapSize / 2);\r\n    mapContext.scale(1 / mapScale, 1 / mapScale);\r\n    mapContext.fillStyle = '#DDD';\r\n    for (const disc of discs) {\r\n        mapContext.beginPath();\r\n        mapContext.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n        mapContext.fill();\r\n    }\r\n    mapContext.restore();\r\n}\r\nfunction render(context, state) {\r\n    context.fillStyle = '#000';\r\n    context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n    context.save();\r\n    context.translate(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH / 2 - state.hero.x, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT / 2 - state.hero.y);\r\n    state.visibleDiscs.sort((A, B) => A.y - B.y);\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge1(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge2(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDisc(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscCenter(context, disc);\r\n    }\r\n    for (const enemy of state.enemies) {\r\n        enemy.definition.render(context, state, enemy);\r\n    }\r\n    for (const enemy of state.enemies) {\r\n        renderEnemyLifebar(context, enemy);\r\n    }\r\n    renderHero(context, state.hero);\r\n    for (const bullet of state.heroBullets) {\r\n        renderHeroBullet(context, bullet);\r\n    }\r\n    for (const bullet of state.enemyBullets) {\r\n        renderEnemyBullet(context, bullet);\r\n    }\r\n    context.restore();\r\n    context.beginPath();\r\n    context.rect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n    context.arc(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH / 2, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT / 2, app_constants__WEBPACK_IMPORTED_MODULE_0__.SIGHT_RADIUS, 0, 2 * Math.PI, true);\r\n    context.fillStyle = '#000';\r\n    context.fill();\r\n    renderHUD(context, state);\r\n}\r\nfunction renderHUD(context, state) {\r\n    if (state.paused) {\r\n        context.save();\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = 'black';\r\n        context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n        context.restore();\r\n        context.fillStyle = 'white';\r\n        context.textBaseline = 'middle';\r\n        context.textAlign = 'center';\r\n        context.font = '32px sans-serif';\r\n        context.fillText('PAUSED', app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH / 2, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT / 2);\r\n    }\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText('Level ' + state.hero.level, 5, 5);\r\n    const lifeRect = { x: 5, y: 30, h: 20, w: 200 };\r\n    renderBar(context, lifeRect, state.hero.life / state.hero.maxLife, 'green', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(state.hero.life + ' / ' + state.hero.maxLife, lifeRect.x + 2, lifeRect.y + lifeRect.h / 2);\r\n    const experienceRect = { x: 5, y: lifeRect.y + lifeRect.h + 5, h: 10, w: 200 };\r\n    const requiredExperience = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_2__.getExperienceForNextLevel)(state.hero.level);\r\n    renderBar(context, experienceRect, state.hero.experience / requiredExperience, 'orange', '#888');\r\n    const minimapRect = state.paused ? largeMapRect : smallMapRect;\r\n    context.fillStyle = 'black';\r\n    context.fillRect(minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.drawImage(mapCanvas, minimapSize / 2 + state.hero.x / mapScale - minimapRect.w / 2, minimapSize / 2 + state.hero.y / mapScale - minimapRect.h / 2, minimapRect.w, minimapRect.h, minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.fillStyle = 'blue';\r\n    context.fillRect(minimapRect.x + minimapRect.w / 2 - 2, minimapRect.y + minimapRect.h / 2 - 2, 4, 4);\r\n    context.fillStyle = 'red';\r\n    for (const enemy of state.enemies) {\r\n        const x = minimapRect.x + minimapRect.w / 2 + (enemy.x - state.hero.x) / mapScale;\r\n        const y = minimapRect.y + minimapRect.w / 2 + (enemy.y - state.hero.y) / mapScale;\r\n        if (x > minimapRect.x + 2 && x < minimapRect.x + minimapRect.w - 2 &&\r\n            y > minimapRect.y + 2 && y < minimapRect.y + minimapRect.h - 2) {\r\n            context.fillRect(x - 2, y - 2, 4, 4);\r\n        }\r\n    }\r\n}\r\nfunction renderBar(context, { x, y, w, h }, p, fillColor, backColor = 'black') {\r\n    context.fillStyle = backColor;\r\n    context.fillRect(x, y, w, h);\r\n    context.fillStyle = fillColor;\r\n    context.fillRect(x, y, w * Math.max(0, Math.min(1, p)), h);\r\n}\r\nfunction renderEnemyLifebar(context, enemy) {\r\n    if (enemy.life < enemy.maxLife) {\r\n        let color = '#0F0';\r\n        if (enemy.life <= enemy.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (enemy.life <= enemy.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        renderBar(context, { x: enemy.x - 15, y: enemy.y - enemy.radius - 8, w: 30, h: 6 }, enemy.life / enemy.maxLife, color);\r\n    }\r\n}\r\nfunction renderEnemyBullet(context, bullet) {\r\n    fillCircle(context, bullet, 'red');\r\n}\r\nfunction renderHeroBullet(context, bullet) {\r\n    fillCircle(context, bullet, 'green');\r\n}\r\nfunction renderHero(context, hero) {\r\n    fillCircle(context, hero, 'blue');\r\n}\r\nfunction fillCircle(context, circle, color) {\r\n    context.fillStyle = color;\r\n    context.beginPath();\r\n    context.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nconst discDepth = 40;\r\nfunction renderDiscEdge1(context, disc) {\r\n    context.fillStyle = '#888';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth);\r\n    context.arc(disc.x, disc.y + discDepth, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDiscEdge2(context, disc) {\r\n    context.fillStyle = '#BBB';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth / 2);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth / 2);\r\n    context.arc(disc.x, disc.y + discDepth / 2, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDisc(context, disc) {\r\n    context.fillStyle = '#DDD';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nfunction renderDiscCenter(context, disc) {\r\n    context.fillStyle = '#FFF';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius / 2, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGame.ts?");

/***/ }),

/***/ "./app/utils/Random.ts":
/*!*****************************!*\
  !*** ./app/utils/Random.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Random = {\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(Math.random() * (max + 1 - min)) + min;\r\n    },\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array[Math.floor(Math.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(Math.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Random);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/Random.ts?");

/***/ }),

/***/ "./app/utils/SRandom.ts":
/*!******************************!*\
  !*** ./app/utils/SRandom.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst MAX_INT = 2 ** 32;\r\n// Decent pseudo random number generator based on:\r\n// https://en.wikipedia.org/wiki/Xorshift\r\n// Values seem fairly evenly distributed on [0, 1)\r\nfunction nextSeed(seed) {\r\n    let x = Math.floor(MAX_INT * seed);\r\n    x ^= x << 13;\r\n    x ^= x >> 17;\r\n    x ^= x << 5;\r\n    return (x / MAX_INT) + 0.5;\r\n}\r\nfunction numberToSeed(number) {\r\n    return nextSeed((Math.cos(number) + 1) / 2);\r\n}\r\n// Seeded random number generator.\r\nclass SRandom {\r\n    constructor(seed) {\r\n        this._seed = seed;\r\n    }\r\n    // Return an instance of SRandom with a seed based on the given value.\r\n    seed(value) {\r\n        return new SRandom(numberToSeed(value));\r\n    }\r\n    // Create a new seed based on the current seed and a given value.\r\n    addSeed(value) {\r\n        return this.seed(this._seed + value);\r\n    }\r\n    nextSeed() {\r\n        return new SRandom(nextSeed(this._seed));\r\n    }\r\n    random() {\r\n        return nextSeed(this._seed);\r\n    }\r\n    // This generates a random number and advances *this* geneator to the next seed.\r\n    generateAndMutate() {\r\n        this._seed = nextSeed(this._seed);\r\n        return this._seed;\r\n    }\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(this.random() * (max + 1 - min)) + min;\r\n    }\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array[Math.floor(this.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(this.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        let randomizer = this;\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(randomizer.random() * currentIndex);\r\n            randomizer = randomizer.nextSeed();\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n;\r\nconst instance = new SRandom(0.5);\r\n// @ts-ignore\r\nwindow['SRandom'] = instance;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/SRandom.ts?");

/***/ }),

/***/ "./app/utils/canvas.ts":
/*!*****************************!*\
  !*** ./app/utils/canvas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   createCanvasAndContext: () => (/* binding */ createCanvasAndContext),\n/* harmony export */   drawCanvas: () => (/* binding */ drawCanvas),\n/* harmony export */   mainCanvas: () => (/* binding */ mainCanvas),\n/* harmony export */   mainContext: () => (/* binding */ mainContext),\n/* harmony export */   require2dContext: () => (/* binding */ require2dContext)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n\r\nconst mainCanvas = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-mainCanvas');\r\n// @ts-ignore\r\nwindow['mainCanvas'] = mainCanvas;\r\n// mainCanvas.width = mainCanvas.height = 512;\r\nconst mainContext = require2dContext(mainCanvas);\r\n// mainContext.imageSmoothingEnabled = false;\r\n// @ts-ignore\r\nwindow['mainContext'] = mainContext;\r\nfunction require2dContext(canvas) {\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n        throw new Error('Failed to get context');\r\n    }\r\n    return context;\r\n}\r\nfunction createCanvas(width, height, classes = '') {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.className = classes;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas;\r\n}\r\nfunction createCanvasAndContext(width, height) {\r\n    const canvas = createCanvas(width, height);\r\n    const context = require2dContext(canvas);\r\n    return [canvas, context];\r\n}\r\n/**\r\n * Safari (and possibly other browsers) will not draw canvases if the source\r\n * rectangle has any parts outside the dimensions of the actual canvas, so this\r\n * method takes arbitrary rectangles and then modifies them to only draw the\r\n * part that overlaps with the canvas.\r\n */\r\nfunction drawCanvas(context, canvas, { x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\r\n    if (w > canvas.width - x) {\r\n        const dx = w - (canvas.width - x);\r\n        w += dx;\r\n        tw += dx;\r\n    }\r\n    if (h > canvas.height - y) {\r\n        const dy = h - (canvas.height - y);\r\n        h += dy;\r\n        th += dy;\r\n    }\r\n    if (x < 0) {\r\n        tx -= x;\r\n        tw += x;\r\n        w += x;\r\n        x = 0;\r\n    }\r\n    if (y < 0) {\r\n        ty -= y;\r\n        th += y;\r\n        h += y;\r\n        y = 0;\r\n    }\r\n    if (w > 0 && h > 0) {\r\n        context.drawImage(canvas, x, y, w, h, tx, ty, tw, th);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/canvas.ts?");

/***/ }),

/***/ "./app/utils/dom.ts":
/*!**************************!*\
  !*** ./app/utils/dom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bodyDiv: () => (/* binding */ bodyDiv),\n/* harmony export */   divider: () => (/* binding */ divider),\n/* harmony export */   findEmptyElement: () => (/* binding */ findEmptyElement),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getDomRectCenter: () => (/* binding */ getDomRectCenter),\n/* harmony export */   getElementIndex: () => (/* binding */ getElementIndex),\n/* harmony export */   handleChildEvent: () => (/* binding */ handleChildEvent),\n/* harmony export */   mainContent: () => (/* binding */ mainContent),\n/* harmony export */   mouseContainer: () => (/* binding */ mouseContainer),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   tag: () => (/* binding */ tag),\n/* harmony export */   tagElement: () => (/* binding */ tagElement),\n/* harmony export */   titleDiv: () => (/* binding */ titleDiv),\n/* harmony export */   toggleElement: () => (/* binding */ toggleElement),\n/* harmony export */   toggleElements: () => (/* binding */ toggleElements)\n/* harmony export */ });\nfunction query(className) {\r\n    return document.querySelector(className);\r\n}\r\nfunction queryAll(className) {\r\n    return document.querySelectorAll(className);\r\n}\r\nconst mouseContainer = query('.js-mouseContainer');\r\nconst mainContent = query('.js-gameContent');\r\nfunction tag(type, classes = '', content = '') {\r\n    return '<' + type + ' class=\"' + classes + '\">' + content + '</' + type + '>';\r\n}\r\nfunction tagElement(type, classes = '', content = '') {\r\n    const element = document.createElement(type);\r\n    element.className = classes || '';\r\n    element.innerHTML = '' + (content || '');\r\n    return element;\r\n}\r\nconst divider = tag('div', 'centered medium', tag('div', 'divider'));\r\nfunction titleDiv(titleMarkup) {\r\n    return titleMarkup && tag('div', 'title', titleMarkup);\r\n}\r\nfunction bodyDiv(bodyMarkup) {\r\n    return bodyMarkup && tag('div', 'body', bodyMarkup);\r\n}\r\n;\r\nfunction findEmptyElement(elements) {\r\n    return [...elements].find(element => element.innerHTML === '');\r\n}\r\nfunction getDomRectCenter(r) {\r\n    return [r.x + r.width / 2, r.y + r.height / 2];\r\n}\r\nfunction getClosestElement(element, elements, threshold) {\r\n    let closestElement = null;\r\n    let closestDistanceSquared = threshold * threshold;\r\n    const center = getDomRectCenter(element.getBoundingClientRect());\r\n    elements.forEach(element => {\r\n        const elementCenter = getDomRectCenter(element.getBoundingClientRect());\r\n        const d2 = (center[0] - elementCenter[0]) ** 2 + (center[1] - elementCenter[1]) ** 2;\r\n        if (d2 <= closestDistanceSquared) {\r\n            closestDistanceSquared = d2;\r\n            closestElement = element;\r\n        }\r\n    });\r\n    return closestElement;\r\n}\r\nfunction toggleElements(elements, show) {\r\n    elements.forEach(element => toggleElement(element, show));\r\n}\r\nfunction toggleElement(element, show) {\r\n    element.style.display = show ? '' : 'none';\r\n}\r\nfunction handleChildEvent(eventType, container, selector, handler) {\r\n    container.addEventListener(eventType, event => {\r\n        const element = event.target;\r\n        const matchedElement = element.closest(selector);\r\n        if (matchedElement) {\r\n            return handler(matchedElement, event);\r\n        }\r\n    });\r\n}\r\nfunction getElementIndex(element) {\r\n    if (!element.parentElement) {\r\n        return -1;\r\n    }\r\n    return [...element.parentElement.children].indexOf(element);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dom.ts?");

/***/ }),

/***/ "./app/utils/dungeon.ts":
/*!******************************!*\
  !*** ./app/utils/dungeon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTreeDungeon: () => (/* binding */ createTreeDungeon),\n/* harmony export */   linkDiscs: () => (/* binding */ linkDiscs),\n/* harmony export */   projectDiscToClosestDisc: () => (/* binding */ projectDiscToClosestDisc),\n/* harmony export */   startDungeon: () => (/* binding */ startDungeon)\n/* harmony export */ });\n/* harmony import */ var app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enemies/chaser */ \"./app/enemies/chaser.ts\");\n/* harmony import */ var app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/circler */ \"./app/enemies/circler.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst platformSizes = [300, 500, 800];\r\nfunction createTreeDungeon(seed, radius, level) {\r\n    const discs = [];\r\n    const enemies = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_6__[\"default\"].seed(seed);\r\n    const startingPlatform = {\r\n        x: 0,\r\n        y: 0,\r\n        radius: dungeonRandomizer.element(platformSizes),\r\n        links: [],\r\n    };\r\n    discs.push(startingPlatform);\r\n    for (let i = 0; i < 100; i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 2 * Math.PI * dungeonRandomizer.generateAndMutate();\r\n        const newDisc = {\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n            links: [],\r\n        };\r\n        projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        discs.push(newDisc);\r\n        // TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(newDisc.x, newDisc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__.turret, level));\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(newDisc.x, newDisc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_2__.lord, level));\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(newDisc.x + 50, newDisc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__.chaser, level));\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(newDisc.x - 50, newDisc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__.chaser, level));\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(newDisc.x, newDisc.y + 50, app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__.circler, level));\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_4__.createEnemy)(newDisc.x, newDisc.y - 50, app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__.circler, level));\r\n        }\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            break;\r\n        }\r\n    }\r\n    linkDiscs(discs);\r\n    return {\r\n        discs,\r\n        enemies,\r\n        entrance,\r\n    };\r\n}\r\nfunction startDungeon(state, dungeon) {\r\n    state.hero.x = dungeon.entrance.x;\r\n    state.hero.y = dungeon.entrance.y;\r\n    state.activeDiscs = dungeon.discs;\r\n    state.visibleDiscs = dungeon.discs;\r\n    state.enemies = dungeon.enemies;\r\n}\r\nfunction projectDiscToClosestDisc(discs, newDisc, overlap) {\r\n    const closestDisc = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.findClosestDisc)(newDisc, discs);\r\n    const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.getTargetVector)(closestDisc, newDisc);\r\n    const m = Math.sqrt(distance2);\r\n    const distance = closestDisc.radius + newDisc.radius - overlap;\r\n    newDisc.x = closestDisc.x + x / m * distance;\r\n    newDisc.y = closestDisc.y + y / m * distance;\r\n}\r\nfunction linkDiscs(discs) {\r\n    for (let i = 0; i < discs.length; i++) {\r\n        const disc = discs[i];\r\n        for (let j = i + 1; j < discs.length; j++) {\r\n            const otherDisc = discs[j];\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_5__.getTargetVector)(disc, otherDisc);\r\n            const minDistance = disc.radius + otherDisc.radius - 16;\r\n            if (distance2 <= minDistance * minDistance) {\r\n                disc.links.push(otherDisc);\r\n                otherDisc.links.push(disc);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dungeon.ts?");

/***/ }),

/***/ "./app/utils/enemy.ts":
/*!****************************!*\
  !*** ./app/utils/enemy.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEnemy: () => (/* binding */ createEnemy),\n/* harmony export */   moveEnemyInCurrentDirection: () => (/* binding */ moveEnemyInCurrentDirection),\n/* harmony export */   shootEnemyBullet: () => (/* binding */ shootEnemyBullet)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\r\nfunction createEnemy(x, y, definition, level) {\r\n    var _a, _b, _c, _d;\r\n    const heroDamage = Math.ceil(20 * Math.pow(1.05, level));\r\n    const heroAttacksPerSecond = 2 + 0.02 * level;\r\n    const heroMaxLife = 20 * (level + 1);\r\n    const dps = heroAttacksPerSecond * heroDamage;\r\n    const targetDuration = 2 + level * 8 / 100;\r\n    const maxLife = Math.ceil((dps * targetDuration) * ((_a = definition.statFactors.maxLife) !== null && _a !== void 0 ? _a : 1));\r\n    return {\r\n        definition,\r\n        x,\r\n        y,\r\n        maxLife,\r\n        life: maxLife,\r\n        level,\r\n        speed: 75 * ((_b = definition.statFactors.speed) !== null && _b !== void 0 ? _b : 1) * (0.9 + 0.2 * Math.random()),\r\n        armor: level,\r\n        damage: Math.floor((heroMaxLife / 10 + heroMaxLife / 10 * level / 100) * ((_c = definition.statFactors.damage) !== null && _c !== void 0 ? _c : 1)),\r\n        attacksPerSecond: (1 + 0.05 * level) * ((_d = definition.statFactors.attacksPerSecond) !== null && _d !== void 0 ? _d : 1),\r\n        attackCooldown: 0,\r\n        radius: definition.radius,\r\n        theta: 0,\r\n        minions: [],\r\n    };\r\n}\r\nfunction shootEnemyBullet(state, enemy, vx, vy, duration = 1000) {\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push({\r\n        //x: enemy.x + vx / mag * enemy.radius,\r\n        //y: enemy.y + vy / mag * enemy.radius,\r\n        x: enemy.x,\r\n        y: enemy.y,\r\n        damage: enemy.damage,\r\n        radius: 5,\r\n        vx,\r\n        vy,\r\n        expirationTime: state.fieldTime + duration,\r\n    });\r\n}\r\nfunction moveEnemyInCurrentDirection(state, enemy) {\r\n    enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/enemy.ts?");

/***/ }),

/***/ "./app/utils/geometry.ts":
/*!*******************************!*\
  !*** ./app/utils/geometry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   findClosestDisc: () => (/* binding */ findClosestDisc),\n/* harmony export */   getTargetVector: () => (/* binding */ getTargetVector),\n/* harmony export */   turnTowardsAngle: () => (/* binding */ turnTowardsAngle)\n/* harmony export */ });\nfunction findClosestDisc({ x, y }, discs) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestDisc = discs[0];\r\n    for (const disc of discs) {\r\n        const dx = disc.x - x, dy = disc.y - y;\r\n        const distance2 = dx * dx + dy * dy - disc.radius * disc.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestDisc = disc;\r\n        }\r\n    }\r\n    return closestDisc;\r\n}\r\nfunction getTargetVector(circleA, circleB) {\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 <= 0) {\r\n        return { x: 1, y: 0, distance2: 0 };\r\n    }\r\n    return { x: dx, y: dy, distance2 };\r\n}\r\nfunction turnTowardsAngle(theta, delta, targetTheta) {\r\n    const negativeDistance = (theta - targetTheta + 2 * Math.PI) % (2 * Math.PI);\r\n    const positiveDistance = (targetTheta - theta + 2 * Math.PI) % (2 * Math.PI);\r\n    if (negativeDistance <= delta || positiveDistance <= delta) {\r\n        return targetTheta;\r\n    }\r\n    if (negativeDistance < positiveDistance) {\r\n        return theta - delta;\r\n    }\r\n    return theta + delta;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/geometry.ts?");

/***/ }),

/***/ "./app/utils/hero.ts":
/*!***************************!*\
  !*** ./app/utils/hero.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gainExperience: () => (/* binding */ gainExperience),\n/* harmony export */   getExperienceForNextLevel: () => (/* binding */ getExperienceForNextLevel)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\r\nfunction gainExperience(state, experience) {\r\n    let requiredExperience = getExperienceForNextLevel(state.hero.level);\r\n    // You cannot gain more than 100% of the experience for the next level at once.\r\n    state.hero.experience += Math.min(experience, requiredExperience);\r\n    if (state.hero.experience >= requiredExperience) {\r\n        state.hero.level++;\r\n        state.hero.experience -= requiredExperience;\r\n        state.hero.damage = Math.ceil(20 * Math.pow(1.05, state.hero.level));\r\n        state.hero.attacksPerSecond = 2 + 0.02 * state.hero.level;\r\n        state.hero.maxLife = 20 * (state.hero.level + 1);\r\n        state.hero.life = state.hero.maxLife;\r\n    }\r\n}\r\nfunction getExperienceForNextLevel(currentLevel) {\r\n    const averageKills = 10 * (currentLevel + 1);\r\n    const xpPerKill = Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_XP * Math.pow(1.2, currentLevel));\r\n    return averageKills * xpPerKill;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/hero.ts?");

/***/ }),

/***/ "./app/utils/mouse.ts":
/*!****************************!*\
  !*** ./app/utils/mouse.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   bindMouseListeners: () => (/* binding */ bindMouseListeners),\n/* harmony export */   getMousePosition: () => (/* binding */ getMousePosition),\n/* harmony export */   isMouseDown: () => (/* binding */ isMouseDown),\n/* harmony export */   isMouseOverElement: () => (/* binding */ isMouseOverElement),\n/* harmony export */   isRightMouseDown: () => (/* binding */ isRightMouseDown)\n/* harmony export */ });\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n//import { CANVAS_SCALE } from 'app/constants';\r\n\r\n\r\nlet mousePosition = [-1000, -1000];\r\nlet mouseIsDown = false;\r\nfunction isMouseDown() {\r\n    return mouseIsDown;\r\n}\r\nfunction getMousePosition(container = null, scale = 1) {\r\n    if (container) {\r\n        const containerRect = container.getBoundingClientRect();\r\n        return [\r\n            (mousePosition[0] - containerRect.x) / scale,\r\n            (mousePosition[1] - containerRect.y) / scale,\r\n        ];\r\n    }\r\n    return [mousePosition[0] / scale, mousePosition[1] / scale];\r\n}\r\nfunction onMouseMove(event) {\r\n    mousePosition = [event.pageX, event.pageY];\r\n    // console.log(mousePosition);\r\n}\r\nfunction onMouseDown(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = true;\r\n}\r\nfunction onMouseUp(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = false;\r\n}\r\nfunction bindMouseListeners() {\r\n    document.addEventListener('mousemove', onMouseMove);\r\n    document.addEventListener('mousedown', onMouseDown);\r\n    document.addEventListener('mouseup', onMouseUp);\r\n}\r\n/* This would in theory be used if we ever cleaned up the application\r\nexport function unbindMouseListeners() {\r\n    document.removeEventListener('mousemove', onMouseMove);\r\n    document.removeEventListener('mousedown', onMouseDown);\r\n    document.removeEventListener('mouseup', onMouseUp);\r\n    // Prevent mouse from being \"stuck down\"\r\n    mouseIsDown = false;\r\n}*/\r\nfunction isMouseOverElement(element) {\r\n    const rect = element.getBoundingClientRect();\r\n    return mousePosition[0] >= rect.x && mousePosition[0] <= rect.x + rect.width\r\n        && mousePosition[1] >= rect.y && mousePosition[1] <= rect.y + rect.height;\r\n}\r\n//let lastContextClick: number[];\r\nlet rightMouseIsDown = false;\r\nfunction isRightMouseDown() {\r\n    return rightMouseIsDown;\r\n}\r\nfunction addContextMenuListeners() {\r\n    document.addEventListener('mouseup', function (event) {\r\n        if (event.which === 3) {\r\n            rightMouseIsDown = false;\r\n            return;\r\n        }\r\n    });\r\n    document.addEventListener('mousedown', function (event) {\r\n        if (event.which === 3) {\r\n            rightMouseIsDown = true;\r\n            return;\r\n        }\r\n    });\r\n    // Prevent the context menu from displaying when clicking over the canvas unless shift is held.\r\n    app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.addEventListener('contextmenu', function (event) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.KEY.SHIFT)) {\r\n            return;\r\n        }\r\n        event.preventDefault();\r\n        // const [x, y] = getMousePosition();\r\n        // lastContextClick = getMousePosition(mainCanvas, CANVAS_SCALE);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/mouse.ts?");

/***/ }),

/***/ "./app/utils/userInput.ts":
/*!********************************!*\
  !*** ./app/utils/userInput.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KEY: () => (/* binding */ KEY),\n/* harmony export */   addKeyboardListeners: () => (/* binding */ addKeyboardListeners),\n/* harmony export */   clearKeyboardState: () => (/* binding */ clearKeyboardState),\n/* harmony export */   isGameKeyDown: () => (/* binding */ isGameKeyDown),\n/* harmony export */   isKeyboardKeyDown: () => (/* binding */ isKeyboardKeyDown),\n/* harmony export */   updateKeyboardState: () => (/* binding */ updateKeyboardState),\n/* harmony export */   wasGameKeyPressed: () => (/* binding */ wasGameKeyPressed),\n/* harmony export */   wasGameKeyPressedAndReleased: () => (/* binding */ wasGameKeyPressedAndReleased)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\r\nconst KEY = {\r\n    ESCAPE: 27,\r\n    LEFT: 37,\r\n    RIGHT: 39,\r\n    UP: 38,\r\n    DOWN: 40,\r\n    SPACE: 32,\r\n    SHIFT: 16,\r\n    ENTER: 13,\r\n    BACK_SPACE: 8,\r\n    COMMAND: 91,\r\n    CONTROL: 17,\r\n    LEFT_BRACKET: 219,\r\n    BACK_SLASH: 220,\r\n    RIGHT_BRACKET: 221,\r\n    A: 'A'.charCodeAt(0),\r\n    C: 'C'.charCodeAt(0),\r\n    D: 'D'.charCodeAt(0),\r\n    E: 'E'.charCodeAt(0),\r\n    F: 'F'.charCodeAt(0),\r\n    G: 'G'.charCodeAt(0),\r\n    H: 'H'.charCodeAt(0),\r\n    I: 'I'.charCodeAt(0),\r\n    J: 'J'.charCodeAt(0),\r\n    K: 'K'.charCodeAt(0),\r\n    L: 'L'.charCodeAt(0),\r\n    M: 'M'.charCodeAt(0),\r\n    O: 'O'.charCodeAt(0),\r\n    P: 'P'.charCodeAt(0),\r\n    Q: 'Q'.charCodeAt(0),\r\n    R: 'R'.charCodeAt(0),\r\n    S: 'S'.charCodeAt(0),\r\n    T: 'T'.charCodeAt(0),\r\n    U: 'U'.charCodeAt(0),\r\n    V: 'V'.charCodeAt(0),\r\n    W: 'W'.charCodeAt(0),\r\n    X: 'X'.charCodeAt(0),\r\n    Y: 'Y'.charCodeAt(0),\r\n    Z: 'Z'.charCodeAt(0),\r\n};\r\nconst KEYBOARD_MAPPINGS = {\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: [KEY.ENTER],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [KEY.UP, KEY.W],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [KEY.DOWN, KEY.S],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [KEY.LEFT, KEY.A],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [KEY.RIGHT, KEY.D],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RUN]: [KEY.SPACE],\r\n};\r\nconst ANALOG_THRESHOLD = 0.3;\r\nconst keysDown = [];\r\nfunction isKeyboardKeyDown(keyCode) {\r\n    if (keysDown[keyCode]) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction addKeyboardListeners() {\r\n    document.addEventListener('keyup', function (event) {\r\n        const keyCode = event.which;\r\n        keysDown[keyCode] = 0;\r\n    });\r\n    document.addEventListener('keydown', function (event) {\r\n        if (event.repeat) {\r\n            return;\r\n        }\r\n        // Don't process keys if an input is targeted, otherwise we prevent typing in\r\n        // the input.\r\n        if (event.target.closest('input')\r\n            || event.target.closest('textarea')\r\n            || event.target.closest('select')) {\r\n            return;\r\n        }\r\n        const commandIsDown = (keysDown[KEY.CONTROL] || keysDown[KEY.COMMAND]);\r\n        const keyCode = event.which;\r\n        //console.log(keyCode);\r\n        // Don't override the refresh page command.\r\n        if (keyCode === KEY.R && commandIsDown) {\r\n            return;\r\n        }\r\n        keysDown[keyCode] = 1;\r\n    });\r\n}\r\nfunction updateKeyboardState(state) {\r\n    const previousGameKeysDown = state.keyboard.gameKeysDown;\r\n    // This set is persisted until a new set of keys is pressed.\r\n    let mostRecentKeysPressed = state.keyboard.mostRecentKeysPressed;\r\n    const gameKeyValues = [];\r\n    const gameKeysDown = new Set();\r\n    const gameKeysPressed = new Set();\r\n    const gameKeysReleased = new Set();\r\n    /*for (const gameKey of GAME_PAD_AXIS_MAPPINGS) {\r\n\r\n    }*/\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n        for (const keyboardCode of (KEYBOARD_MAPPINGS[gameKey] || [])) {\r\n            gameKeyValues[gameKey] = isKeyboardKeyDown(keyboardCode);\r\n            if (gameKeyValues[gameKey]) {\r\n                break;\r\n            }\r\n        }\r\n        if (gameKeyValues[gameKey] >= ANALOG_THRESHOLD) {\r\n            gameKeysDown.add(gameKey);\r\n        }\r\n    }\r\n    for (const oldKeyDown of [...previousGameKeysDown]) {\r\n        if (!gameKeysDown.has(oldKeyDown)) {\r\n            gameKeysReleased.add(oldKeyDown);\r\n        }\r\n    }\r\n    for (const newKeyDown of [...gameKeysDown]) {\r\n        if (!previousGameKeysDown.has(newKeyDown)) {\r\n            gameKeysPressed.add(newKeyDown);\r\n        }\r\n    }\r\n    if (gameKeysPressed.size > 0) {\r\n        mostRecentKeysPressed = gameKeysPressed;\r\n    }\r\n    state.keyboard = { gameKeyValues, gameKeysDown, gameKeysPressed, gameKeysReleased, mostRecentKeysPressed };\r\n}\r\nfunction clearKeyboardState(state) {\r\n    const gameKeyValues = [];\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n    }\r\n    state.keyboard = {\r\n        gameKeyValues,\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n    };\r\n}\r\nfunction wasGameKeyPressed(state, keyCode) {\r\n    return state.keyboard.gameKeysPressed.has(keyCode);\r\n}\r\n// Only returns true if a key was pressed and released without any other keys having been pressed in between.\r\n// Specifically this is used to determined whether to switch clones, which should only happen if the user presses\r\n// the clone tool button without pressing any other buttons before releasing it. Note that it is okay if they\r\n// continue holding buttons that were already down when pressing the clone button.\r\nfunction wasGameKeyPressedAndReleased(state, keyCode) {\r\n    return state.keyboard.mostRecentKeysPressed.has(keyCode) && state.keyboard.gameKeysReleased.has(keyCode);\r\n}\r\nfunction isGameKeyDown(state, keyCode) {\r\n    return state.keyboard.gameKeysDown.has(keyCode);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/userInput.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/client.ts");
/******/ 	
/******/ })()
;