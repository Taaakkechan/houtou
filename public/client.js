/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./app/bosses/guardian.ts":
/*!********************************!*\
  !*** ./app/bosses/guardian.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   guardian: () => (/* binding */ guardian)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n\r\n\r\n\r\n\r\n\r\nconst guardian = {\r\n    name: 'Guardian',\r\n    statFactors: {\r\n        maxLife: 5,\r\n        damage: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    experienceFactor: 20,\r\n    radius: 40,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        if (enemy.mode === 'choose') {\r\n            enemy.speed = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.chaseTarget)(state, enemy, state.hero);\r\n            if (enemy.modeTime >= 400) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].element(['moveToEdge', 'moveToEdge', 'chase']));\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'moveToEdge') {\r\n            enemy.speed = 1.2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            let { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy.disc, enemy);\r\n            if (distance2 >= (enemy.disc.radius * 0.8) ** 2) {\r\n                enemy.setMode(app_utils_Random__WEBPACK_IMPORTED_MODULE_4__[\"default\"].element(['shoot', 'shoot', 'circle']));\r\n            }\r\n            else {\r\n                enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy);\r\n            }\r\n        }\r\n        if (enemy.mode === 'shoot') {\r\n            if (enemy.modeTime < 600) {\r\n                const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n                enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n            }\r\n            if (enemy.modeTime === 1000) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 300 * Math.cos(enemy.theta), 200 * Math.sin(enemy.theta), {\r\n                    expirationTime: state.fieldTime + 2000,\r\n                    damage: enemy.damage * 5,\r\n                    radius: 3 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS,\r\n                });\r\n            }\r\n            if (enemy.modeTime >= 1500) {\r\n                enemy.setMode('charge');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'charge') {\r\n            enemy.speed = 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy);\r\n            if (enemy.modeTime % 200 === 0) {\r\n                const vx = 120 * Math.cos(enemy.theta + Math.PI / 2);\r\n                const vy = 120 * Math.sin(enemy.theta + Math.PI / 2);\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, vx, vy, { expirationTime: state.fieldTime + 3000 });\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, -vx, -vy, { expirationTime: state.fieldTime + 3000 });\r\n            }\r\n            if (enemy.modeTime >= 3000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            // Stop earlier if it hits the outside of the ring.\r\n            if (enemy.modeTime >= 1000) {\r\n                let { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy.disc, enemy);\r\n                if (distance2 >= (enemy.disc.radius * 0.9) ** 2) {\r\n                    enemy.setMode('choose');\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'chase') {\r\n            enemy.speed = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.chaseTarget)(state, enemy, state.hero);\r\n            if (enemy.modeTime % 800 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 6, 3, 200);\r\n            }\r\n            if (enemy.modeTime >= 5000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n        if (enemy.mode === 'circle') {\r\n            enemy.speed = 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED;\r\n            let { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            enemy.theta = Math.atan2(y, x);\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInDirection)(state, enemy, enemy.theta + Math.PI / 2);\r\n            if (enemy.modeTime % 600 === 0) {\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootBulletArc)(state, enemy, enemy.theta, Math.PI / 6, 3, 200);\r\n            }\r\n            if (enemy.modeTime >= 6000) {\r\n                enemy.setMode('choose');\r\n            }\r\n            return;\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta + Math.PI / 6),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta + Math.PI / 6),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 30 * Math.cos(enemy.theta - Math.PI / 6),\r\n            y: enemy.y + 30 * Math.sin(enemy.theta - Math.PI / 6),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/bosses/guardian.ts?");

/***/ }),

/***/ "./app/client.ts":
/*!***********************!*\
  !*** ./app/client.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/enemies/chaser */ \"./app/enemies/chaser.ts\");\n/* harmony import */ var app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/circler */ \"./app/enemies/circler.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_loot__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/loot */ \"./app/loot.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_dungeon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/dungeon */ \"./app/utils/dungeon.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_initialize__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! app/initialize */ \"./app/initialize.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst testDiscs = [\r\n    { x: 500, y: 500, radius: 500, links: [] },\r\n    { x: 1200, y: 1200, radius: 800, links: [] },\r\n    { x: 500, y: -200, radius: 500, links: [] },\r\n];\r\nlet state = {\r\n    fieldTime: 0,\r\n    hero: {\r\n        level: 1,\r\n        experience: 0,\r\n        speed: 100,\r\n        x: 500,\r\n        y: 500,\r\n        radius: 15,\r\n        theta: 0,\r\n        damageHistory: [],\r\n        recentDamageTaken: 0,\r\n        weapon: app_utils_Random__WEBPACK_IMPORTED_MODULE_13__[\"default\"].element([app_weapons__WEBPACK_IMPORTED_MODULE_16__.bows, app_weapons__WEBPACK_IMPORTED_MODULE_16__.daggers, app_weapons__WEBPACK_IMPORTED_MODULE_16__.swords])[0],\r\n        // Derived stats will get set later.\r\n        life: 0,\r\n        maxLife: 0,\r\n        armor: 0,\r\n        damage: 0,\r\n        attacksPerSecond: 0,\r\n        attackCooldown: 0,\r\n        chargingLevel: 1,\r\n        attackChargeLevel: 1,\r\n        potions: app_constants__WEBPACK_IMPORTED_MODULE_14__.BASE_MAX_POTIONS,\r\n    },\r\n    heroBullets: [],\r\n    enemies: [],\r\n    loot: [],\r\n    portals: [],\r\n    enemyBullets: [],\r\n    fieldText: [],\r\n    activeDiscs: testDiscs,\r\n    visibleDiscs: testDiscs,\r\n    gameHasBeenInitialized: false,\r\n    paused: false,\r\n    keyboard: {\r\n        gameKeyValues: [],\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n    },\r\n};\r\n// @ts-ignore\r\nwindow['state'] = state;\r\nfunction getState() {\r\n    return state;\r\n}\r\nfunction update() {\r\n    const state = getState();\r\n    if (!state.gameHasBeenInitialized) {\r\n        (0,app_initialize__WEBPACK_IMPORTED_MODULE_15__.initializeGame)(state);\r\n        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.setDerivedHeroStats)(state);\r\n        (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_7__.startDungeon)(state, (0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_7__.createTreeDungeon)(Math.random(), 2000, 1));\r\n    }\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.updateKeyboardState)(state);\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.MENU)) {\r\n        state.paused = !state.paused;\r\n        if (state.paused) {\r\n            (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_5__.render)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__.mainContext, state);\r\n        }\r\n    }\r\n    if (state.paused) {\r\n        return;\r\n    }\r\n    state.fieldTime += app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n    if (state.hero.life <= 0) {\r\n        return;\r\n    }\r\n    updateHero(state);\r\n    updateEnemies(state);\r\n    updateHeroBullets(state);\r\n    updateEnemyBullets(state);\r\n    state.fieldText = state.fieldText.filter(t => t.expirationTime > state.fieldTime);\r\n    for (const fieldText of state.fieldText) {\r\n        fieldText.x += fieldText.vx;\r\n        fieldText.y += fieldText.vy;\r\n        fieldText.time += app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n    }\r\n    if (state.enemies.filter(e => !e.master).length < 0) {\r\n        for (const disc of state.activeDiscs) {\r\n            if (disc === state.hero.disc) {\r\n                continue;\r\n            }\r\n            if (Math.random() < 0.05) {\r\n                const definition = app_utils_Random__WEBPACK_IMPORTED_MODULE_13__[\"default\"].element([app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__.turret, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__.chaser, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_0__.chaser, app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__.circler, app_enemies_circler__WEBPACK_IMPORTED_MODULE_1__.circler, app_enemies_lord__WEBPACK_IMPORTED_MODULE_2__.lord]);\r\n                const radius = definition === app_enemies_turret__WEBPACK_IMPORTED_MODULE_3__.turret ? disc.radius / 8 : disc.radius / 4;\r\n                const theta = Math.random() * 2 * Math.PI;\r\n                let level = Math.floor(state.hero.level / 2);\r\n                while (Math.random() < 0.5 && level < state.hero.level) {\r\n                    level++;\r\n                }\r\n                const enemy = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_8__.createEnemy)(disc.x + radius * Math.cos(theta), disc.y + radius * Math.sin(theta), definition, level);\r\n                state.enemies.push(enemy);\r\n            }\r\n        }\r\n    }\r\n    state.activeLoot = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__.getClosestElement)(state.hero, state.loot);\r\n    if (state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__.getTargetVector)(state.hero, state.activeLoot).distance2 >= (state.activeLoot.radius + state.hero.radius + 10) ** 2) {\r\n        delete state.activeLoot;\r\n    }\r\n    if (state.activeLoot && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.ACTIVATE)) {\r\n        state.activeLoot.activate(state, state.activeLoot);\r\n    }\r\n    else if (state.activeLoot && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.SELL)) {\r\n        const level = state.activeLoot.getLevel(state.activeLoot);\r\n        const experiencePenalty = Math.min(1, Math.max(0, (state.hero.level - level) * 0.1));\r\n        (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.gainExperience)(state, Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_14__.BASE_XP * (1 - experiencePenalty) * Math.pow(1.2, level) * 1.5));\r\n        state.loot.splice(state.loot.indexOf(state.activeLoot), 1);\r\n        delete state.activeLoot;\r\n    }\r\n}\r\nfunction addDamageNumber(state, target, damage) {\r\n    state.fieldText.push({\r\n        x: target.x - 5 + Math.random() * 10,\r\n        y: target.y - 10,\r\n        vx: 2 * Math.random() - 1,\r\n        vy: -1,\r\n        text: `${damage}`,\r\n        color: 'red',\r\n        borderColor: 'black',\r\n        expirationTime: state.fieldTime + 1000,\r\n        time: 0,\r\n    });\r\n}\r\nfunction updateHero(state) {\r\n    var _a, _b;\r\n    const hero = state.hero;\r\n    // Hero damage frames\r\n    hero.damageHistory.unshift(0);\r\n    if (hero.damageHistory.length > app_constants__WEBPACK_IMPORTED_MODULE_14__.HERO_DAMAGE_FRAME_COUNT) {\r\n        const oldDamage = hero.damageHistory.pop();\r\n        hero.recentDamageTaken -= oldDamage;\r\n    }\r\n    // Hero movement\r\n    let dx = 0, dy = 0;\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.UP)) {\r\n        dy--;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.DOWN)) {\r\n        dy++;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.LEFT)) {\r\n        dx--;\r\n    }\r\n    if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.isGameKeyDown)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.RIGHT)) {\r\n        dx++;\r\n    }\r\n    const m = Math.sqrt(dx * dx + dy * dy);\r\n    if (m > 1) {\r\n        dx /= m;\r\n        dy /= m;\r\n    }\r\n    const speed = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_11__.isRightMouseDown)() ? hero.speed : 1.5 * hero.speed;\r\n    hero.x += dx * speed / app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n    hero.y += dy * speed / app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n    // Hero attack\r\n    const [x, y] = (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_11__.getMousePosition)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__.mainCanvas, app_constants__WEBPACK_IMPORTED_MODULE_14__.CANVAS_SCALE);\r\n    let aimDx = x - app_constants__WEBPACK_IMPORTED_MODULE_14__.CANVAS_WIDTH / 2, aimDy = y - app_constants__WEBPACK_IMPORTED_MODULE_14__.CANVAS_HEIGHT / 2;\r\n    hero.theta = Math.atan2(aimDy, aimDx);\r\n    const attacksPerSecond = hero.weapon.attacksPerSecond * hero.attacksPerSecond;\r\n    if ((0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_11__.isMouseDown)()) {\r\n        const attackCooldownDuration = 1000 / attacksPerSecond;\r\n        if (hero.attackCooldown <= state.fieldTime) {\r\n            hero.attackCooldown = state.fieldTime + attackCooldownDuration;\r\n            hero.attackChargeLevel = Math.max(1, Math.floor(hero.chargingLevel));\r\n            state.hero.chargingLevel = 0;\r\n        }\r\n        const attackTime = attackCooldownDuration - (hero.attackCooldown - state.fieldTime);\r\n        for (const shot of hero.weapon.shots) {\r\n            const shotTime = attackCooldownDuration * ((_a = shot.timingOffset) !== null && _a !== void 0 ? _a : 0);\r\n            if (shotTime >= attackTime - app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH / 2 && shotTime < attackTime + app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH / 2) {\r\n                state.heroBullets.push(shot.generateBullet(state, hero, hero.weapon));\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        hero.chargingLevel = Math.min(hero.weapon.chargeLevel, \r\n        // Charging gets slower for each charge level.\r\n        //hero.chargingLevel + FRAME_LENGTH * attacksPerSecond / 1000 / Math.floor(hero.chargingLevel + 1)\r\n        hero.chargingLevel + app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH * attacksPerSecond / 1000);\r\n    }\r\n    if (!((_b = state.hero.disc) === null || _b === void 0 ? void 0 : _b.boss)) {\r\n        assignToDisc(state.hero, state.activeDiscs);\r\n    }\r\n    constrainToDisc(state.hero, state.hero.disc);\r\n    for (const portal of state.portals) {\r\n        const isActive = !state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__.doCirclesIntersect)(state.hero, portal);\r\n        if (isActive && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.ACTIVATE)) {\r\n            console.log('activate');\r\n            portal.activate(state);\r\n        }\r\n    }\r\n    if (hero.potions > 0 && hero.life < hero.maxLife && (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_12__.wasGameKeyPressed)(state, app_constants__WEBPACK_IMPORTED_MODULE_14__.GAME_KEY.POTION)) {\r\n        hero.life = Math.min(hero.maxLife, Math.ceil(hero.life + hero.maxLife * 0.2));\r\n        hero.potions--;\r\n    }\r\n}\r\nfunction damageHero(state, damage) {\r\n    // Incoming damage is limited by both the amount of the damage and the players total health.\r\n    // Shots that deal X damage only deal damage if the player has taken less than 2X damage recently.\r\n    // A player cannot take more than 50% of their health over their recorded damage history.\r\n    const damageCap = Math.min(state.hero.maxLife / 2, 2 * damage);\r\n    const damageTaken = Math.max(0, Math.min(damage, damageCap - state.hero.recentDamageTaken));\r\n    state.hero.life -= damageTaken;\r\n    if (state.hero.life < 0) {\r\n        state.hero.life = 0;\r\n    }\r\n    state.hero.damageHistory[0] += damageTaken;\r\n    state.hero.recentDamageTaken += damageTaken;\r\n    addDamageNumber(state, state.hero, damageTaken);\r\n}\r\nfunction updateEnemies(state) {\r\n    var _a, _b, _c;\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    for (const enemy of state.enemies) {\r\n        // Freeze enemies outside of the boss fight.\r\n        if (boss && ((_b = enemy.disc) === null || _b === void 0 ? void 0 : _b.boss) !== boss) {\r\n            continue;\r\n        }\r\n        // Freeze bosses that are not activated.\r\n        if (!boss && ((_c = enemy.disc) === null || _c === void 0 ? void 0 : _c.boss) === enemy) {\r\n            continue;\r\n        }\r\n        enemy.modeTime += app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n        enemy.definition.update(state, enemy);\r\n        // No changing discs during boss fights.\r\n        if (!boss) {\r\n            assignToDisc(enemy, state.activeDiscs);\r\n        }\r\n        constrainToDisc(enemy, enemy.disc);\r\n    }\r\n}\r\nfunction updateHeroBullets(state) {\r\n    var _a, _b, _c, _d, _e;\r\n    const activeBullets = state.heroBullets.filter(b => b.expirationTime >= state.fieldTime);\r\n    state.heroBullets = [];\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    for (const bullet of activeBullets) {\r\n        bullet.x += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n        bullet.y += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n        let bulletAbsorbed = false;\r\n        for (const enemy of state.enemies) {\r\n            // Freeze enemies outside of the boss fight.\r\n            if (boss && ((_b = enemy.disc) === null || _b === void 0 ? void 0 : _b.boss) !== boss) {\r\n                continue;\r\n            }\r\n            // Freeze bosses that are not activated.\r\n            if (!boss && ((_c = enemy.disc) === null || _c === void 0 ? void 0 : _c.boss) === enemy) {\r\n                continue;\r\n            }\r\n            if (bullet.hitTargets.has(enemy)) {\r\n                continue;\r\n            }\r\n            if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__.doCirclesIntersect)(enemy, bullet)) {\r\n                bullet.hitTargets.add(enemy);\r\n                enemy.life -= bullet.damage;\r\n                addDamageNumber(state, enemy, bullet.damage);\r\n                if (enemy.life <= 0) {\r\n                    const experiencePenalty = Math.min(1, Math.max(0, (state.hero.level - enemy.level) * 0.1));\r\n                    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_10__.gainExperience)(state, Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_14__.BASE_XP * (1 - experiencePenalty) * Math.pow(1.2, enemy.level) * ((_d = enemy.definition.experienceFactor) !== null && _d !== void 0 ? _d : 1)));\r\n                    (0,app_loot__WEBPACK_IMPORTED_MODULE_4__.checkToDropBasicLoot)(state, enemy);\r\n                    if (((_e = enemy.disc) === null || _e === void 0 ? void 0 : _e.boss) === enemy) {\r\n                        delete enemy.disc.boss;\r\n                        state.portals.push((0,app_utils_dungeon__WEBPACK_IMPORTED_MODULE_7__.getTreeDungeonPortal)(enemy.disc.x, enemy.disc.y, enemy.level - 1, Math.random()));\r\n                    }\r\n                }\r\n                else {\r\n                    // Shots are not absorbed by defeated enemies.\r\n                    bulletAbsorbed = !bullet.isEnemyPiercing;\r\n                }\r\n            }\r\n        }\r\n        if (!bulletAbsorbed) {\r\n            state.heroBullets.push(bullet);\r\n        }\r\n    }\r\n    state.enemies = state.enemies.filter(e => e.life > 0);\r\n}\r\nfunction updateEnemyBullets(state) {\r\n    const activeBullets = state.enemyBullets.filter(b => b.expirationTime >= state.fieldTime);\r\n    state.enemyBullets = [];\r\n    for (const bullet of activeBullets) {\r\n        bullet.x += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n        bullet.y += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH;\r\n        let hitTarget = false;\r\n        if ((0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__.doCirclesIntersect)(state.hero, bullet)) {\r\n            hitTarget = true;\r\n            damageHero(state, bullet.damage);\r\n        }\r\n        if (!hitTarget) {\r\n            state.enemyBullets.push(bullet);\r\n        }\r\n    }\r\n    state.enemies = state.enemies.filter(e => e.life > 0);\r\n}\r\nfunction assignToDisc(geometry, discs) {\r\n    geometry.disc = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_9__.findClosestDisc)(geometry, discs);\r\n}\r\nfunction constrainToDisc(geometry, disc) {\r\n    if (!disc) {\r\n        return;\r\n    }\r\n    const dx = geometry.x - disc.x, dy = geometry.y - disc.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 > disc.radius * disc.radius) {\r\n        const m = Math.sqrt(distance2);\r\n        geometry.x = disc.x + disc.radius * dx / m;\r\n        geometry.y = disc.y + disc.radius * dy / m;\r\n    }\r\n}\r\nfunction renderLoop() {\r\n    try {\r\n        window.requestAnimationFrame(renderLoop);\r\n        const state = getState();\r\n        if (!state.paused) {\r\n            (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_5__.render)(app_utils_canvas__WEBPACK_IMPORTED_MODULE_6__.mainContext, state);\r\n        }\r\n    }\r\n    catch (e) {\r\n        console.log(e);\r\n        debugger;\r\n    }\r\n}\r\nrenderLoop();\r\nsetInterval(update, app_constants__WEBPACK_IMPORTED_MODULE_14__.FRAME_LENGTH);\r\n\n\n//# sourceURL=webpack://alttp/./app/client.ts?");

/***/ }),

/***/ "./app/constants.ts":
/*!**************************!*\
  !*** ./app/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BASE_ATTACKS_PER_SECOND: () => (/* binding */ BASE_ATTACKS_PER_SECOND),\n/* harmony export */   BASE_BULLET_DURATION: () => (/* binding */ BASE_BULLET_DURATION),\n/* harmony export */   BASE_BULLET_RADIUS: () => (/* binding */ BASE_BULLET_RADIUS),\n/* harmony export */   BASE_BULLET_SPEED: () => (/* binding */ BASE_BULLET_SPEED),\n/* harmony export */   BASE_DROP_CHANCE: () => (/* binding */ BASE_DROP_CHANCE),\n/* harmony export */   BASE_ENEMY_BULLET_DURATION: () => (/* binding */ BASE_ENEMY_BULLET_DURATION),\n/* harmony export */   BASE_ENEMY_BULLET_RADIUS: () => (/* binding */ BASE_ENEMY_BULLET_RADIUS),\n/* harmony export */   BASE_ENEMY_SPEED: () => (/* binding */ BASE_ENEMY_SPEED),\n/* harmony export */   BASE_MAX_POTIONS: () => (/* binding */ BASE_MAX_POTIONS),\n/* harmony export */   BASE_WEAPON_DPS_PER_LEVEL: () => (/* binding */ BASE_WEAPON_DPS_PER_LEVEL),\n/* harmony export */   BASE_XP: () => (/* binding */ BASE_XP),\n/* harmony export */   CANVAS_HEIGHT: () => (/* binding */ CANVAS_HEIGHT),\n/* harmony export */   CANVAS_SCALE: () => (/* binding */ CANVAS_SCALE),\n/* harmony export */   CANVAS_WIDTH: () => (/* binding */ CANVAS_WIDTH),\n/* harmony export */   FRAME_LENGTH: () => (/* binding */ FRAME_LENGTH),\n/* harmony export */   GAME_KEY: () => (/* binding */ GAME_KEY),\n/* harmony export */   HERO_DAMAGE_FRAME_COUNT: () => (/* binding */ HERO_DAMAGE_FRAME_COUNT),\n/* harmony export */   SIGHT_RADIUS: () => (/* binding */ SIGHT_RADIUS)\n/* harmony export */ });\nconst FRAME_LENGTH = 20;\r\nconst CANVAS_WIDTH = 800;\r\nconst CANVAS_HEIGHT = 800;\r\nconst CANVAS_SCALE = 1;\r\nconst SIGHT_RADIUS = 400;\r\nconst GAME_KEY = {\r\n    MENU: 0,\r\n    UP: 1,\r\n    DOWN: 2,\r\n    LEFT: 3,\r\n    RIGHT: 4,\r\n    RUN: 5,\r\n    ACTIVATE: 6,\r\n    SELL: 7,\r\n    POTION: 8,\r\n};\r\nconst BASE_DROP_CHANCE = 0.1;\r\nconst HERO_DAMAGE_FRAME_COUNT = 20;\r\nconst BASE_MAX_POTIONS = 5;\r\nconst BASE_XP = 10;\r\nconst BASE_ATTACKS_PER_SECOND = 2;\r\nconst BASE_WEAPON_DPS_PER_LEVEL = 40;\r\nconst BASE_BULLET_SPEED = 200;\r\nconst BASE_BULLET_RADIUS = 5;\r\nconst BASE_BULLET_DURATION = 1000;\r\nconst BASE_ENEMY_SPEED = 80;\r\nconst BASE_ENEMY_BULLET_RADIUS = 5;\r\nconst BASE_ENEMY_BULLET_DURATION = 1000;\r\n\n\n//# sourceURL=webpack://alttp/./app/constants.ts?");

/***/ }),

/***/ "./app/enemies/chaser.ts":
/*!*******************************!*\
  !*** ./app/enemies/chaser.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chaser: () => (/* binding */ chaser)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst chaser = {\r\n    name: 'Chaser',\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n    },\r\n    initialParams: {},\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta));\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/chaser.ts?");

/***/ }),

/***/ "./app/enemies/chest.ts":
/*!******************************!*\
  !*** ./app/enemies/chest.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chest: () => (/* binding */ chest)\n/* harmony export */ });\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n\r\nconst chest = {\r\n    name: 'Chest',\r\n    statFactors: {},\r\n    initialParams: {},\r\n    dropChance: 1,\r\n    experienceFactor: 0,\r\n    radius: 25,\r\n    update(state, enemy) {\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, enemy, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...enemy, radius: 20 }, 'pink');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_0__.fillCircle)(context, { ...enemy, radius: 6 }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/chest.ts?");

/***/ }),

/***/ "./app/enemies/circler.ts":
/*!********************************!*\
  !*** ./app/enemies/circler.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circler: () => (/* binding */ circler)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst circler = {\r\n    name: 'Circler',\r\n    statFactors: {\r\n        maxLife: 1,\r\n        damage: 1,\r\n        attacksPerSecond: 2,\r\n        speed: 0.6,\r\n    },\r\n    initialParams: {},\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 200;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        let targetTheta = enemy.theta;\r\n        if (distance2 < aggroRadius * aggroRadius) {\r\n            // Face the player, to shoot at them and circle them.\r\n            targetTheta = Math.atan2(y, x);\r\n            if (distance2 > 100 * 100) {\r\n                targetTheta -= Math.PI / 12;\r\n            }\r\n        }\r\n        else {\r\n            // Face the disc to shoot around it and circle it.\r\n            const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, enemy.disc);\r\n            targetTheta = Math.atan2(y, x);\r\n            // Curve towards the center of the disc when too far out.\r\n            if (distance2 > enemy.disc.radius * enemy.disc.radius / 4) {\r\n                targetTheta -= Math.PI / 12;\r\n            }\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, targetTheta);\r\n        // Note this enemy moves sideways.\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta + Math.PI / 2) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta + Math.PI / 2) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta));\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta + Math.PI), 100 * Math.sin(enemy.theta + Math.PI));\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 10 * Math.cos(enemy.theta),\r\n            y: enemy.y + 10 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 10 * Math.cos(enemy.theta + Math.PI),\r\n            y: enemy.y + 10 * Math.sin(enemy.theta + Math.PI),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/circler.ts?");

/***/ }),

/***/ "./app/enemies/lord.ts":
/*!*****************************!*\
  !*** ./app/enemies/lord.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lord: () => (/* binding */ lord),\n/* harmony export */   lordsMinion: () => (/* binding */ lordsMinion)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst lord = {\r\n    name: 'Lord',\r\n    statFactors: {\r\n        maxLife: 3,\r\n        damage: 1,\r\n        attacksPerSecond: 0.4,\r\n        speed: 0.4,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 5,\r\n    radius: 20,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const aggroRadius = 600;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n        enemy.minions = enemy.minions.filter(m => m.life > 0);\r\n        if (enemy.attackCooldown <= state.fieldTime && enemy.minions.length < 5) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (const theta of [enemy.theta + Math.PI / 2, enemy.theta - Math.PI / 2]) {\r\n                const minion = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.createEnemy)(enemy.x + enemy.radius * Math.cos(theta), enemy.y + enemy.radius * Math.sin(theta), lordsMinion, enemy.level);\r\n                minion.theta = theta;\r\n                enemy.minions.push(minion);\r\n                minion.master = enemy;\r\n                state.enemies.push(minion);\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 5,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 15 * Math.cos(enemy.theta),\r\n            y: enemy.y + 15 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\nfunction turnTowardsTarget(state, enemy, target) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n}\r\nconst lordsMinion = {\r\n    name: 'Peasant',\r\n    statFactors: {\r\n        maxLife: 0.5,\r\n        damage: 0.5,\r\n        attacksPerSecond: 0.5,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 0,\r\n    experienceFactor: 0.1,\r\n    radius: 15,\r\n    update(state, enemy) {\r\n        if (!enemy.disc) {\r\n            return;\r\n        }\r\n        const master = enemy.master && enemy.master.life > 0 ? enemy.master : undefined;\r\n        const aggroRadius = 400;\r\n        const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 <= aggroRadius * aggroRadius) {\r\n            // Leash back to master for a bit after attacking.\r\n            if (master && enemy.attackCooldown - state.fieldTime > 400) {\r\n                // Enemy moves in its current direction unless it gets too far from the master.\r\n                const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, master);\r\n                if (distance2 >= 300 * 300) {\r\n                    turnTowardsTarget(state, enemy, master);\r\n                }\r\n            }\r\n            else {\r\n                // Chase the player when it can attack soon.\r\n                turnTowardsTarget(state, enemy, state.hero);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n            if (enemy.attackCooldown <= state.fieldTime) {\r\n                enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(enemy.theta), 100 * Math.sin(enemy.theta));\r\n            }\r\n        }\r\n        else if (master) {\r\n            // Enemy moves in its current direction unless it gets too far from the master.\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, master);\r\n            if (distance2 >= 200 * 200) {\r\n                turnTowardsTarget(state, enemy, master);\r\n            }\r\n            (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.moveEnemyInCurrentDirection)(state, enemy);\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 12 * Math.cos(enemy.theta),\r\n            y: enemy.y + 12 * Math.sin(enemy.theta),\r\n            radius: 2,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 2,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/lord.ts?");

/***/ }),

/***/ "./app/enemies/turret.ts":
/*!*******************************!*\
  !*** ./app/enemies/turret.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   turret: () => (/* binding */ turret)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n\r\n\r\n\r\n\r\nconst turret = {\r\n    name: 'Turret',\r\n    statFactors: {\r\n        maxLife: 2,\r\n        damage: 1,\r\n        attacksPerSecond: 1,\r\n    },\r\n    initialParams: {},\r\n    dropChance: 2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE,\r\n    experienceFactor: 2,\r\n    radius: 25,\r\n    update(state, enemy) {\r\n        const aggroRadius = 400;\r\n        const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.getTargetVector)(enemy, state.hero);\r\n        if (distance2 > aggroRadius * aggroRadius) {\r\n            enemy.theta += 0.01;\r\n            return;\r\n        }\r\n        enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_3__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n        if (enemy.attackCooldown <= state.fieldTime) {\r\n            enemy.attackCooldown = state.fieldTime + 1000 / enemy.attacksPerSecond;\r\n            for (let i = 0; i < 3; i++) {\r\n                const theta = enemy.theta - Math.PI / 6 + Math.PI / 6 * i;\r\n                (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_2__.shootEnemyBullet)(state, enemy, 100 * Math.cos(theta), 100 * Math.sin(theta));\r\n            }\r\n        }\r\n    },\r\n    render(context, state, enemy) {\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, enemy, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 20,\r\n        }, 'black');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x,\r\n            y: enemy.y,\r\n            radius: 15,\r\n        }, 'orange');\r\n        (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_1__.fillCircle)(context, {\r\n            x: enemy.x + 20 * Math.cos(enemy.theta),\r\n            y: enemy.y + 20 * Math.sin(enemy.theta),\r\n            radius: 5,\r\n        }, 'black');\r\n    }\r\n};\r\n\n\n//# sourceURL=webpack://alttp/./app/enemies/turret.ts?");

/***/ }),

/***/ "./app/initialize.ts":
/*!***************************!*\
  !*** ./app/initialize.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initializeGame: () => (/* binding */ initializeGame)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n/* harmony import */ var app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/mouse */ \"./app/utils/mouse.ts\");\n\r\n\r\n\r\nfunction initializeGame(state) {\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.bindMouseListeners)();\r\n    (0,app_utils_mouse__WEBPACK_IMPORTED_MODULE_2__.addContextMenuListeners)();\r\n    (0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.addKeyboardListeners)();\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-loading').style.display = 'none';\r\n    (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-gameContent').style.display = '';\r\n    state.gameHasBeenInitialized = true;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/initialize.ts?");

/***/ }),

/***/ "./app/loot.ts":
/*!*********************!*\
  !*** ./app/loot.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkToDropBasicLoot: () => (/* binding */ checkToDropBasicLoot)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n/* harmony import */ var app_utils_Random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/Random */ \"./app/utils/Random.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n\r\n\r\n\r\n\r\nfunction checkToDropBasicLoot(state, source) {\r\n    var _a;\r\n    if (Math.random() < ((_a = source.definition.dropChance) !== null && _a !== void 0 ? _a : app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE)) {\r\n        const weaponType = app_utils_Random__WEBPACK_IMPORTED_MODULE_2__[\"default\"].element(app_weapons__WEBPACK_IMPORTED_MODULE_1__.allWeapons);\r\n        let weaponIndex = 0;\r\n        for (; weaponIndex < app_weapons__WEBPACK_IMPORTED_MODULE_1__.allWeapons.length - 1; weaponIndex++) {\r\n            if (weaponType[weaponIndex + 1].level > source.level && Math.random() >= app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_DROP_CHANCE) {\r\n                break;\r\n            }\r\n        }\r\n        const weapon = weaponType[weaponIndex];\r\n        state.loot.push({\r\n            type: 'weapon',\r\n            x: source.x,\r\n            y: source.y,\r\n            radius: 12,\r\n            weapon,\r\n            activate(state, loot) {\r\n                const temp = state.hero.weapon;\r\n                state.hero.weapon = loot.weapon;\r\n                loot.weapon = temp;\r\n            },\r\n            render(context, state, loot) {\r\n                (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_3__.fillCircle)(context, loot, 'gold');\r\n                if (state.activeLoot === loot) {\r\n                    context.fillStyle = '#88F';\r\n                    context.textBaseline = 'middle';\r\n                    context.textAlign = 'center';\r\n                    context.font = '16px sans-serif';\r\n                    context.fillText(loot.weapon.name, loot.x, loot.y);\r\n                }\r\n                else {\r\n                    context.fillStyle = '#88F';\r\n                    context.textBaseline = 'middle';\r\n                    context.textAlign = 'center';\r\n                    context.font = '16px sans-serif';\r\n                    context.fillText(loot.weapon.type.charAt(0).toUpperCase() + loot.weapon.level, loot.x, loot.y);\r\n                }\r\n            },\r\n            getLevel(loot) {\r\n                return weapon.level;\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/loot.ts?");

/***/ }),

/***/ "./app/render/renderGame.ts":
/*!**********************************!*\
  !*** ./app/render/renderGame.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fillCircle: () => (/* binding */ fillCircle),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   renderMinimap: () => (/* binding */ renderMinimap)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n\r\n\r\n\r\n\r\nconst minimapSize = 500;\r\nconst smallMapRect = { x: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 155, y: 5, w: 150, h: 150 };\r\nconst largeMapRect = { x: (app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 400) / 2, y: (app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 400) / 2, w: 400, h: 400 };\r\nconst [mapCanvas, mapContext] = (0,app_utils_canvas__WEBPACK_IMPORTED_MODULE_1__.createCanvasAndContext)(minimapSize, minimapSize);\r\nconst mapScale = 20;\r\nfunction renderMinimap(discs) {\r\n    mapContext.fillStyle = '#000';\r\n    mapContext.fillRect(0, 0, minimapSize, minimapSize);\r\n    mapContext.save();\r\n    mapContext.translate(minimapSize / 2, minimapSize / 2);\r\n    mapContext.scale(1 / mapScale, 1 / mapScale);\r\n    for (const disc of discs) {\r\n        mapContext.fillStyle = disc.boss ? '#FBB' : '#DDD';\r\n        mapContext.beginPath();\r\n        mapContext.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n        mapContext.fill();\r\n    }\r\n    mapContext.restore();\r\n}\r\nfunction render(context, state) {\r\n    var _a, _b, _c;\r\n    context.fillStyle = '#000';\r\n    context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n    context.save();\r\n    context.translate(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH / 2 - state.hero.x, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT / 2 - state.hero.y);\r\n    state.visibleDiscs.sort((A, B) => A.y - B.y);\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge1(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscEdge2(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDisc(context, disc);\r\n    }\r\n    for (const disc of state.visibleDiscs) {\r\n        renderDiscCenter(context, disc);\r\n    }\r\n    for (const portal of state.portals) {\r\n        renderPortal(context, state, portal);\r\n    }\r\n    if ((_b = (_a = state.hero) === null || _a === void 0 ? void 0 : _a.disc) === null || _b === void 0 ? void 0 : _b.boss) {\r\n        context.save();\r\n        context.translate(-(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH / 2 - state.hero.x), -(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT / 2 - state.hero.y));\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = '#000';\r\n        context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n        context.restore();\r\n        renderDisc(context, state.hero.disc);\r\n        renderDiscCenter(context, state.hero.disc);\r\n    }\r\n    for (const loot of state.loot) {\r\n        if (loot === state.activeLoot) {\r\n            continue;\r\n        }\r\n        loot.render(context, state, loot);\r\n    }\r\n    (_c = state.activeLoot) === null || _c === void 0 ? void 0 : _c.render(context, state, state.activeLoot);\r\n    for (const enemy of state.enemies) {\r\n        enemy.definition.render(context, state, enemy);\r\n    }\r\n    for (const enemy of state.enemies) {\r\n        renderEnemyLifebar(context, enemy);\r\n    }\r\n    renderHero(context, state, state.hero);\r\n    for (const bullet of state.heroBullets) {\r\n        renderHeroBullet(context, bullet);\r\n    }\r\n    for (const bullet of state.enemyBullets) {\r\n        renderEnemyBullet(context, bullet);\r\n    }\r\n    for (const fieldText of state.fieldText) {\r\n        renderFieldText(context, fieldText);\r\n    }\r\n    context.restore();\r\n    context.beginPath();\r\n    context.rect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n    context.arc(app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH / 2, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT / 2, app_constants__WEBPACK_IMPORTED_MODULE_0__.SIGHT_RADIUS, 0, 2 * Math.PI, true);\r\n    context.fillStyle = '#000';\r\n    context.fill();\r\n    renderHUD(context, state);\r\n}\r\nfunction renderHUD(context, state) {\r\n    var _a;\r\n    if (state.paused) {\r\n        context.save();\r\n        context.globalAlpha *= 0.6;\r\n        context.fillStyle = 'black';\r\n        context.fillRect(0, 0, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH, app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT);\r\n        context.restore();\r\n        /*context.fillStyle = 'white';\r\n        context.textBaseline = 'middle';\r\n        context.textAlign = 'center';\r\n        context.font = '32px sans-serif';\r\n        context.fillText('PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);*/\r\n    }\r\n    const minimapRect = state.paused ? largeMapRect : smallMapRect;\r\n    context.fillStyle = 'black';\r\n    context.fillRect(minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.drawImage(mapCanvas, minimapSize / 2 + state.hero.x / mapScale - minimapRect.w / 2, minimapSize / 2 + state.hero.y / mapScale - minimapRect.h / 2, minimapRect.w, minimapRect.h, minimapRect.x, minimapRect.y, minimapRect.w, minimapRect.h);\r\n    context.fillStyle = '#08F';\r\n    context.fillRect(minimapRect.x + minimapRect.w / 2 - 3, minimapRect.y + minimapRect.h / 2 - 3, 6, 6);\r\n    context.fillStyle = 'red';\r\n    for (const enemy of state.enemies) {\r\n        const x = minimapRect.x + minimapRect.w / 2 + (enemy.x - state.hero.x) / mapScale;\r\n        const y = minimapRect.y + minimapRect.w / 2 + (enemy.y - state.hero.y) / mapScale;\r\n        if (x > minimapRect.x + 2 && x < minimapRect.x + minimapRect.w - 2 &&\r\n            y > minimapRect.y + 2 && y < minimapRect.y + minimapRect.h - 2) {\r\n            context.fillRect(x - 2, y - 2, 4, 4);\r\n        }\r\n    }\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'top';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText('Level ' + state.hero.level, 5, 5);\r\n    const lifeRect = { x: 5, y: 30, h: 20, w: 200 };\r\n    renderBar(context, lifeRect, state.hero.life / state.hero.maxLife, 'green', '#888');\r\n    context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'left';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(state.hero.life + ' / ' + state.hero.maxLife, lifeRect.x + 2, lifeRect.y + lifeRect.h / 2 + 2);\r\n    const experienceRect = { x: 5, y: lifeRect.y + lifeRect.h + 5, h: 10, w: 200 };\r\n    const requiredExperience = (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_3__.getExperienceForNextLevel)(state.hero.level);\r\n    renderBar(context, experienceRect, state.hero.experience / requiredExperience, 'orange', '#888');\r\n    context.strokeStyle = 'red';\r\n    context.fillStyle = 'red';\r\n    for (let i = 0; i < app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_MAX_POTIONS; i++) {\r\n        if (i < state.hero.potions) {\r\n            context.fillRect(5 + i * 15, experienceRect.y + experienceRect.h + 5, 10, 15);\r\n        }\r\n        context.strokeRect(5 + i * 15, experienceRect.y + experienceRect.h + 5, 10, 15);\r\n    }\r\n    const boss = (_a = state.hero.disc) === null || _a === void 0 ? void 0 : _a.boss;\r\n    if (boss) {\r\n        const lifeRect = { x: 5, y: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_HEIGHT - 30, h: 24, w: app_constants__WEBPACK_IMPORTED_MODULE_0__.CANVAS_WIDTH - 10 };\r\n        let color = '#0F0';\r\n        if (boss.life <= boss.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (boss.life <= boss.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        renderBar(context, lifeRect, boss.life / boss.maxLife, color, '#444');\r\n        context.fillStyle = 'white';\r\n        context.textBaseline = 'middle';\r\n        context.textAlign = 'left';\r\n        context.font = '20px sans-serif';\r\n        context.fillText(boss.definition.name + ' ' + boss.life + ' / ' + boss.maxLife, lifeRect.x + 2, lifeRect.y + lifeRect.h / 2 + 2);\r\n    }\r\n}\r\nfunction renderBar(context, { x, y, w, h }, p, fillColor, backColor = 'black') {\r\n    context.fillStyle = backColor;\r\n    context.fillRect(x, y, w, h);\r\n    context.fillStyle = fillColor;\r\n    context.fillRect(x, y, w * Math.max(0, Math.min(1, p)), h);\r\n}\r\nfunction renderPortal(context, state, portal) {\r\n    const isActive = !state.activeLoot && (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_2__.doCirclesIntersect)(state.hero, portal);\r\n    fillCircle(context, portal, isActive ? '#BBB' : '#666');\r\n    fillCircle(context, { ...portal, radius: portal.radius * 0.9 }, '#000');\r\n    context.fillStyle = isActive ? '#FFF' : '#88F';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(`Level ` + portal.level, portal.x, portal.y - 10);\r\n    context.fillText(portal.name, portal.x, portal.y + 10);\r\n}\r\nfunction renderEnemyLifebar(context, enemy) {\r\n    if (enemy.life < enemy.maxLife) {\r\n        let color = '#0F0';\r\n        if (enemy.life <= enemy.maxLife / 4) {\r\n            color = '#F00';\r\n        }\r\n        else if (enemy.life <= enemy.maxLife / 2) {\r\n            color = '#F80';\r\n        }\r\n        renderBar(context, { x: enemy.x - 15, y: enemy.y - enemy.radius - 8, w: 30, h: 6 }, enemy.life / enemy.maxLife, color);\r\n    }\r\n}\r\nfunction renderEnemyBullet(context, bullet) {\r\n    fillCircle(context, bullet, 'red');\r\n}\r\nfunction renderHeroBullet(context, bullet) {\r\n    fillCircle(context, bullet, 'green');\r\n}\r\nfunction renderHero(context, state, hero) {\r\n    if (hero.attackCooldown > state.fieldTime && hero.attackChargeLevel >= 2) {\r\n        // While charged attack still applies, draw an orange halo.\r\n        context.save();\r\n        context.globalAlpha *= (0.45 + 0.15 * Math.sin(state.fieldTime / 100));\r\n        const chargeRadius = hero.radius * 1.2;\r\n        fillCircle(context, { x: hero.x, y: hero.y, radius: chargeRadius }, 'orange');\r\n        context.restore();\r\n    }\r\n    else if (hero.chargingLevel >= 2) {\r\n        context.save();\r\n        const color = hero.chargingLevel >= 2 ? 'red' : 'orange';\r\n        context.globalAlpha *= (0.45 + 0.15 * Math.sin(state.fieldTime / 100));\r\n        const chargeRadius = 2 * Math.floor(hero.chargingLevel);\r\n        fillCircle(context, { x: hero.x, y: hero.y, radius: hero.radius + chargeRadius }, color);\r\n        context.restore();\r\n    }\r\n    context.save();\r\n    if (hero.life <= 0) {\r\n        context.globalAlpha *= 0.5;\r\n    }\r\n    else if (hero.recentDamageTaken) {\r\n        const fadeAmount = 0.2 + 0.3 * hero.recentDamageTaken / (hero.maxLife / 2);\r\n        //context.globalAlpha *= (1 - fadeAmount / 2 + fadeAmount * Math.sin(state.fieldTime / 80));\r\n        context.globalAlpha *= (1 - fadeAmount);\r\n    }\r\n    fillCircle(context, hero, 'blue');\r\n    context.restore();\r\n    // Debug code to render charge level on hero\r\n    /*context.fillStyle = 'white';\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    context.font = '16px sans-serif';\r\n    context.fillText(state.hero.chargingLevel.toFixed(2), hero.x, hero.y);*/\r\n}\r\nfunction renderFieldText(context, fieldText) {\r\n    context.textBaseline = 'middle';\r\n    context.textAlign = 'center';\r\n    let size = 20;\r\n    if (fieldText.time < 300) {\r\n        size = 50 - 25 * fieldText.time / 300;\r\n    }\r\n    context.font = `${size}px bold sans-serif`;\r\n    if (fieldText.borderColor) {\r\n        context.fillStyle = fieldText.borderColor;\r\n        /*context.fillText(fieldText.text, fieldText.x - 1, fieldText.y - 1);\r\n        context.fillText(fieldText.text, fieldText.x - 1, fieldText.y + 1);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y - 1);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y + 1);*/\r\n        context.fillText(fieldText.text, fieldText.x - 1, fieldText.y);\r\n        context.fillText(fieldText.text, fieldText.x + 1, fieldText.y);\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y + 1);\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y - 1);\r\n    }\r\n    /*if (fieldText.borderColor) {\r\n        context.strokeStyle = fieldText.borderColor;\r\n        context.strokeText(fieldText.text, fieldText.x, fieldText.y);\r\n    }*/\r\n    if (fieldText.color) {\r\n        context.fillStyle = fieldText.color;\r\n        context.fillText(fieldText.text, fieldText.x, fieldText.y);\r\n    }\r\n}\r\nfunction fillCircle(context, circle, color) {\r\n    context.fillStyle = color;\r\n    context.beginPath();\r\n    context.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nconst discDepth = 40;\r\nfunction renderDiscEdge1(context, disc) {\r\n    context.fillStyle = '#888';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth);\r\n    context.arc(disc.x, disc.y + discDepth, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDiscEdge2(context, disc) {\r\n    context.fillStyle = '#BBB';\r\n    //context.fillRect(disc.x - disc.radius, disc.y, disc.radius * 2, discDepth / 2);\r\n    context.beginPath();\r\n    //context.moveTo(disc.x - disc.radius, disc.y);\r\n    //context.lineTo(disc.x - disc.radius, disc.y + discDepth / 2);\r\n    context.arc(disc.x, disc.y + discDepth / 2, disc.radius, 0, Math.PI);\r\n    //context.lineTo(disc.x + disc.radius, disc.y);\r\n    context.fill();\r\n}\r\nfunction renderDisc(context, disc) {\r\n    context.fillStyle = disc.boss ? '#FBB' : '#DDD';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\nfunction renderDiscCenter(context, disc) {\r\n    context.fillStyle = disc.boss ? '#FCC' : '#FFF';\r\n    context.beginPath();\r\n    context.arc(disc.x, disc.y, disc.radius / 2, 0, 2 * Math.PI);\r\n    context.fill();\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/render/renderGame.ts?");

/***/ }),

/***/ "./app/utils/Random.ts":
/*!*****************************!*\
  !*** ./app/utils/Random.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst Random = {\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(Math.random() * (max + 1 - min)) + min;\r\n    },\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array[Math.floor(Math.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor === Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = Random.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor === Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(Math.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    },\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(Math.random() * currentIndex);\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n};\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Random);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/Random.ts?");

/***/ }),

/***/ "./app/utils/SRandom.ts":
/*!******************************!*\
  !*** ./app/utils/SRandom.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst MAX_INT = 2 ** 32;\r\n// Decent pseudo random number generator based on:\r\n// https://en.wikipedia.org/wiki/Xorshift\r\n// Values seem fairly evenly distributed on [0, 1)\r\nfunction nextSeed(seed) {\r\n    let x = Math.floor(MAX_INT * seed);\r\n    x ^= x << 13;\r\n    x ^= x >> 17;\r\n    x ^= x << 5;\r\n    return (x / MAX_INT) + 0.5;\r\n}\r\nfunction numberToSeed(number) {\r\n    return nextSeed((Math.cos(number) + 1) / 2);\r\n}\r\n// Seeded random number generator.\r\nclass SRandom {\r\n    constructor(seed) {\r\n        this._seed = seed;\r\n    }\r\n    // Return an instance of SRandom with a seed based on the given value.\r\n    seed(value) {\r\n        return new SRandom(numberToSeed(value));\r\n    }\r\n    // Create a new seed based on the current seed and a given value.\r\n    addSeed(value) {\r\n        return this.seed(this._seed + value);\r\n    }\r\n    nextSeed() {\r\n        return new SRandom(nextSeed(this._seed));\r\n    }\r\n    random() {\r\n        return nextSeed(this._seed);\r\n    }\r\n    // This generates a random number and advances *this* geneator to the next seed.\r\n    generateAndMutate() {\r\n        this._seed = nextSeed(this._seed);\r\n        return this._seed;\r\n    }\r\n    /**\r\n     * @param {number} min  The smallest returned value\r\n     * @param {number} max  The largest returned value\r\n     */\r\n    range(A, B) {\r\n        var min = Math.min(A, B);\r\n        var max = Math.max(A, B);\r\n        return Math.floor(this.random() * (max + 1 - min)) + min;\r\n    }\r\n    /**\r\n     * @param {Collection} collection  The collection of elements to return random element from\r\n     */\r\n    element(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            return object[key];\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array[Math.floor(this.random() * array.length)];\r\n        }\r\n        throw new Error(\"Warning @ Random.element: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * @param {Array} array  The array of elements to return random element from\r\n     */\r\n    removeElement(collection) {\r\n        if (collection.constructor == Object) {\r\n            const object = collection;\r\n            const keys = Object.keys(object);\r\n            const key = this.element(keys);\r\n            const value = object[key];\r\n            delete object[key];\r\n            return value;\r\n        }\r\n        if (collection.constructor == Array) {\r\n            const array = collection;\r\n            return array.splice(Math.floor(this.random() * array.length), 1)[0];\r\n        }\r\n        throw new Error(\"Warning @ Random.removeElement: \" + collection + \" is neither Array or Object\");\r\n    }\r\n    /**\r\n     * Shuffles an array.\r\n     *\r\n     * Knuth algorithm found at:\r\n     * http://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n     *\r\n     * @param {Array} array  The array of elements to shuffle\r\n     */\r\n    shuffle(array) {\r\n        let randomizer = this;\r\n        array = [...array];\r\n        let currentIndex = array.length, temporaryValue, randomIndex;\r\n        // While there remain elements to shuffle...\r\n        while (0 !== currentIndex) {\r\n            // Pick a remaining element...\r\n            randomIndex = Math.floor(randomizer.random() * currentIndex);\r\n            randomizer = randomizer.nextSeed();\r\n            currentIndex -= 1;\r\n            // And swap it with the current element.\r\n            temporaryValue = array[currentIndex];\r\n            array[currentIndex] = array[randomIndex];\r\n            array[randomIndex] = temporaryValue;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n;\r\nconst instance = new SRandom(0.5);\r\n// @ts-ignore\r\nwindow['SRandom'] = instance;\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/SRandom.ts?");

/***/ }),

/***/ "./app/utils/canvas.ts":
/*!*****************************!*\
  !*** ./app/utils/canvas.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCanvas: () => (/* binding */ createCanvas),\n/* harmony export */   createCanvasAndContext: () => (/* binding */ createCanvasAndContext),\n/* harmony export */   drawCanvas: () => (/* binding */ drawCanvas),\n/* harmony export */   mainCanvas: () => (/* binding */ mainCanvas),\n/* harmony export */   mainContext: () => (/* binding */ mainContext),\n/* harmony export */   require2dContext: () => (/* binding */ require2dContext)\n/* harmony export */ });\n/* harmony import */ var app_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/dom */ \"./app/utils/dom.ts\");\n\r\nconst mainCanvas = (0,app_utils_dom__WEBPACK_IMPORTED_MODULE_0__.query)('.js-mainCanvas');\r\n// @ts-ignore\r\nwindow['mainCanvas'] = mainCanvas;\r\n// mainCanvas.width = mainCanvas.height = 512;\r\nconst mainContext = require2dContext(mainCanvas);\r\n// mainContext.imageSmoothingEnabled = false;\r\n// @ts-ignore\r\nwindow['mainContext'] = mainContext;\r\nfunction require2dContext(canvas) {\r\n    const context = canvas.getContext('2d');\r\n    if (!context) {\r\n        throw new Error('Failed to get context');\r\n    }\r\n    return context;\r\n}\r\nfunction createCanvas(width, height, classes = '') {\r\n    const canvas = document.createElement('canvas');\r\n    canvas.className = classes;\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    return canvas;\r\n}\r\nfunction createCanvasAndContext(width, height) {\r\n    const canvas = createCanvas(width, height);\r\n    const context = require2dContext(canvas);\r\n    return [canvas, context];\r\n}\r\n/**\r\n * Safari (and possibly other browsers) will not draw canvases if the source\r\n * rectangle has any parts outside the dimensions of the actual canvas, so this\r\n * method takes arbitrary rectangles and then modifies them to only draw the\r\n * part that overlaps with the canvas.\r\n */\r\nfunction drawCanvas(context, canvas, { x, y, w, h }, { x: tx, y: ty, w: tw, h: th }) {\r\n    if (w > canvas.width - x) {\r\n        const dx = w - (canvas.width - x);\r\n        w += dx;\r\n        tw += dx;\r\n    }\r\n    if (h > canvas.height - y) {\r\n        const dy = h - (canvas.height - y);\r\n        h += dy;\r\n        th += dy;\r\n    }\r\n    if (x < 0) {\r\n        tx -= x;\r\n        tw += x;\r\n        w += x;\r\n        x = 0;\r\n    }\r\n    if (y < 0) {\r\n        ty -= y;\r\n        th += y;\r\n        h += y;\r\n        y = 0;\r\n    }\r\n    if (w > 0 && h > 0) {\r\n        context.drawImage(canvas, x, y, w, h, tx, ty, tw, th);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/canvas.ts?");

/***/ }),

/***/ "./app/utils/dom.ts":
/*!**************************!*\
  !*** ./app/utils/dom.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bodyDiv: () => (/* binding */ bodyDiv),\n/* harmony export */   divider: () => (/* binding */ divider),\n/* harmony export */   findEmptyElement: () => (/* binding */ findEmptyElement),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getDomRectCenter: () => (/* binding */ getDomRectCenter),\n/* harmony export */   getElementIndex: () => (/* binding */ getElementIndex),\n/* harmony export */   handleChildEvent: () => (/* binding */ handleChildEvent),\n/* harmony export */   mainContent: () => (/* binding */ mainContent),\n/* harmony export */   mouseContainer: () => (/* binding */ mouseContainer),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   queryAll: () => (/* binding */ queryAll),\n/* harmony export */   tag: () => (/* binding */ tag),\n/* harmony export */   tagElement: () => (/* binding */ tagElement),\n/* harmony export */   titleDiv: () => (/* binding */ titleDiv),\n/* harmony export */   toggleElement: () => (/* binding */ toggleElement),\n/* harmony export */   toggleElements: () => (/* binding */ toggleElements)\n/* harmony export */ });\nfunction query(className) {\r\n    return document.querySelector(className);\r\n}\r\nfunction queryAll(className) {\r\n    return document.querySelectorAll(className);\r\n}\r\nconst mouseContainer = query('.js-mouseContainer');\r\nconst mainContent = query('.js-gameContent');\r\nfunction tag(type, classes = '', content = '') {\r\n    return '<' + type + ' class=\"' + classes + '\">' + content + '</' + type + '>';\r\n}\r\nfunction tagElement(type, classes = '', content = '') {\r\n    const element = document.createElement(type);\r\n    element.className = classes || '';\r\n    element.innerHTML = '' + (content || '');\r\n    return element;\r\n}\r\nconst divider = tag('div', 'centered medium', tag('div', 'divider'));\r\nfunction titleDiv(titleMarkup) {\r\n    return titleMarkup && tag('div', 'title', titleMarkup);\r\n}\r\nfunction bodyDiv(bodyMarkup) {\r\n    return bodyMarkup && tag('div', 'body', bodyMarkup);\r\n}\r\n;\r\nfunction findEmptyElement(elements) {\r\n    return [...elements].find(element => element.innerHTML === '');\r\n}\r\nfunction getDomRectCenter(r) {\r\n    return [r.x + r.width / 2, r.y + r.height / 2];\r\n}\r\nfunction getClosestElement(element, elements, threshold) {\r\n    let closestElement = null;\r\n    let closestDistanceSquared = threshold * threshold;\r\n    const center = getDomRectCenter(element.getBoundingClientRect());\r\n    elements.forEach(element => {\r\n        const elementCenter = getDomRectCenter(element.getBoundingClientRect());\r\n        const d2 = (center[0] - elementCenter[0]) ** 2 + (center[1] - elementCenter[1]) ** 2;\r\n        if (d2 <= closestDistanceSquared) {\r\n            closestDistanceSquared = d2;\r\n            closestElement = element;\r\n        }\r\n    });\r\n    return closestElement;\r\n}\r\nfunction toggleElements(elements, show) {\r\n    elements.forEach(element => toggleElement(element, show));\r\n}\r\nfunction toggleElement(element, show) {\r\n    element.style.display = show ? '' : 'none';\r\n}\r\nfunction handleChildEvent(eventType, container, selector, handler) {\r\n    container.addEventListener(eventType, event => {\r\n        const element = event.target;\r\n        const matchedElement = element.closest(selector);\r\n        if (matchedElement) {\r\n            return handler(matchedElement, event);\r\n        }\r\n    });\r\n}\r\nfunction getElementIndex(element) {\r\n    if (!element.parentElement) {\r\n        return -1;\r\n    }\r\n    return [...element.parentElement.children].indexOf(element);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dom.ts?");

/***/ }),

/***/ "./app/utils/dungeon.ts":
/*!******************************!*\
  !*** ./app/utils/dungeon.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createTreeDungeon: () => (/* binding */ createTreeDungeon),\n/* harmony export */   getTreeDungeonPortal: () => (/* binding */ getTreeDungeonPortal),\n/* harmony export */   linkDiscs: () => (/* binding */ linkDiscs),\n/* harmony export */   projectDiscToClosestDisc: () => (/* binding */ projectDiscToClosestDisc),\n/* harmony export */   startDungeon: () => (/* binding */ startDungeon)\n/* harmony export */ });\n/* harmony import */ var app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/bosses/guardian */ \"./app/bosses/guardian.ts\");\n/* harmony import */ var app_enemies_chaser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/enemies/chaser */ \"./app/enemies/chaser.ts\");\n/* harmony import */ var app_enemies_chest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/enemies/chest */ \"./app/enemies/chest.ts\");\n/* harmony import */ var app_enemies_circler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! app/enemies/circler */ \"./app/enemies/circler.ts\");\n/* harmony import */ var app_enemies_lord__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! app/enemies/lord */ \"./app/enemies/lord.ts\");\n/* harmony import */ var app_enemies_turret__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! app/enemies/turret */ \"./app/enemies/turret.ts\");\n/* harmony import */ var app_render_renderGame__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! app/render/renderGame */ \"./app/render/renderGame.ts\");\n/* harmony import */ var app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! app/utils/enemy */ \"./app/utils/enemy.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_utils_hero__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! app/utils/hero */ \"./app/utils/hero.ts\");\n/* harmony import */ var app_utils_SRandom__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! app/utils/SRandom */ \"./app/utils/SRandom.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst platformSizes = [200, 350, 500];\r\nfunction getTreeDungeonPortal(x, y, level, seed) {\r\n    level = Math.max(0, Math.min(100, level));\r\n    return {\r\n        x, y, radius: 40,\r\n        level,\r\n        name: 'Tree',\r\n        activate(state) {\r\n            startDungeon(state, createTreeDungeon(Math.random(), 2000 + 40 * level, level));\r\n        },\r\n    };\r\n}\r\nfunction createTreeDungeon(seed, radius, level) {\r\n    const discs = [];\r\n    const portals = [];\r\n    const enemies = [];\r\n    const entrance = { x: 0, y: 0, radius: 16 };\r\n    const dungeonRandomizer = app_utils_SRandom__WEBPACK_IMPORTED_MODULE_10__[\"default\"].seed(seed);\r\n    if (level > 1) {\r\n        portals.push(getTreeDungeonPortal(0, 0, level - 1, dungeonRandomizer.generateAndMutate()));\r\n    }\r\n    const startingPlatform = {\r\n        x: 0,\r\n        y: 0,\r\n        radius: 400,\r\n        links: [],\r\n    };\r\n    discs.push(startingPlatform);\r\n    let finished = false;\r\n    for (let i = 0; i < 100 && (!finished || i < 20); i++) {\r\n        dungeonRandomizer.nextSeed();\r\n        const theta = 2 * Math.PI * dungeonRandomizer.generateAndMutate();\r\n        const newDisc = {\r\n            x: radius * Math.cos(theta),\r\n            y: radius * Math.sin(theta),\r\n            radius: dungeonRandomizer.element(platformSizes),\r\n            links: [],\r\n        };\r\n        projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n        if (newDisc.x * newDisc.x + newDisc.y * newDisc.y >= radius * radius) {\r\n            // Only one disc is allowed to spawn outside of the radius.\r\n            if (!finished) {\r\n                finished = true;\r\n                newDisc.radius = 400;\r\n                projectDiscToClosestDisc(discs, newDisc, dungeonRandomizer.range(16, 128));\r\n                newDisc.boss = (0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x, newDisc.y, app_bosses_guardian__WEBPACK_IMPORTED_MODULE_0__.guardian, Math.min(100, level + 2));\r\n                newDisc.boss.isBoss = true;\r\n                enemies.push(newDisc.boss);\r\n                discs.push(newDisc);\r\n            }\r\n            continue;\r\n        }\r\n        discs.push(newDisc);\r\n        // TODO: Add different enemy generators and apply them at random.\r\n        if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x, newDisc.y, app_enemies_turret__WEBPACK_IMPORTED_MODULE_5__.turret, level));\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x, newDisc.y, app_enemies_lord__WEBPACK_IMPORTED_MODULE_4__.lord, level));\r\n        }\r\n        else if (dungeonRandomizer.generateAndMutate() < 0.3) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x, newDisc.y, app_enemies_chest__WEBPACK_IMPORTED_MODULE_2__.chest, level));\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x + 50, newDisc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_1__.chaser, level));\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x - 50, newDisc.y, app_enemies_chaser__WEBPACK_IMPORTED_MODULE_1__.chaser, level));\r\n        }\r\n        if (dungeonRandomizer.generateAndMutate() < 0.5) {\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x, newDisc.y + 50, app_enemies_circler__WEBPACK_IMPORTED_MODULE_3__.circler, level));\r\n            enemies.push((0,app_utils_enemy__WEBPACK_IMPORTED_MODULE_7__.createEnemy)(newDisc.x, newDisc.y - 50, app_enemies_circler__WEBPACK_IMPORTED_MODULE_3__.circler, level));\r\n        }\r\n    }\r\n    linkDiscs(discs);\r\n    return {\r\n        name: 'tree',\r\n        level,\r\n        discs,\r\n        enemies,\r\n        entrance,\r\n        portals,\r\n    };\r\n}\r\nfunction startDungeon(state, dungeon) {\r\n    state.hero.x = dungeon.entrance.x;\r\n    state.hero.y = dungeon.entrance.y;\r\n    state.activeDiscs = dungeon.discs;\r\n    state.visibleDiscs = dungeon.discs;\r\n    state.enemies = dungeon.enemies;\r\n    state.loot = [];\r\n    state.portals = dungeon.portals;\r\n    (0,app_render_renderGame__WEBPACK_IMPORTED_MODULE_6__.renderMinimap)(state.visibleDiscs);\r\n    (0,app_utils_hero__WEBPACK_IMPORTED_MODULE_9__.refillAllPotions)(state);\r\n}\r\nfunction projectDiscToClosestDisc(discs, newDisc, overlap) {\r\n    const closestDisc = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_8__.findClosestDisc)(newDisc, discs);\r\n    const { x, y, distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_8__.getTargetVector)(closestDisc, newDisc);\r\n    const m = Math.sqrt(distance2);\r\n    const distance = closestDisc.radius + newDisc.radius - overlap;\r\n    newDisc.x = closestDisc.x + x / m * distance;\r\n    newDisc.y = closestDisc.y + y / m * distance;\r\n}\r\nfunction linkDiscs(discs) {\r\n    for (let i = 0; i < discs.length; i++) {\r\n        const disc = discs[i];\r\n        for (let j = i + 1; j < discs.length; j++) {\r\n            const otherDisc = discs[j];\r\n            const { distance2 } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_8__.getTargetVector)(disc, otherDisc);\r\n            const minDistance = disc.radius + otherDisc.radius - 16;\r\n            if (distance2 <= minDistance * minDistance) {\r\n                disc.links.push(otherDisc);\r\n                otherDisc.links.push(disc);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/dungeon.ts?");

/***/ }),

/***/ "./app/utils/enemy.ts":
/*!****************************!*\
  !*** ./app/utils/enemy.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   chaseTarget: () => (/* binding */ chaseTarget),\n/* harmony export */   createEnemy: () => (/* binding */ createEnemy),\n/* harmony export */   moveEnemyInCurrentDirection: () => (/* binding */ moveEnemyInCurrentDirection),\n/* harmony export */   moveEnemyInDirection: () => (/* binding */ moveEnemyInDirection),\n/* harmony export */   shootBulletArc: () => (/* binding */ shootBulletArc),\n/* harmony export */   shootEnemyBullet: () => (/* binding */ shootEnemyBullet)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n/* harmony import */ var app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/geometry */ \"./app/utils/geometry.ts\");\n/* harmony import */ var app_weapons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! app/weapons */ \"./app/weapons.ts\");\n\r\n\r\n\r\nfunction createEnemy(x, y, definition, level) {\r\n    var _a, _b, _c, _d;\r\n    const heroDamage = Math.ceil(level * 20 * Math.pow(1.05, level));\r\n    const heroAttacksPerSecond = 2 + 0.02 * level;\r\n    const heroMaxLife = 20 * (level + 1);\r\n    const dps = heroAttacksPerSecond * heroDamage;\r\n    const targetDuration = 2 + level * 8 / 100;\r\n    const maxLife = Math.ceil((dps * targetDuration) * ((_a = definition.statFactors.maxLife) !== null && _a !== void 0 ? _a : 1));\r\n    return {\r\n        definition,\r\n        params: { ...definition.initialParams },\r\n        x,\r\n        y,\r\n        maxLife,\r\n        life: maxLife,\r\n        level,\r\n        speed: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_SPEED * ((_b = definition.statFactors.speed) !== null && _b !== void 0 ? _b : 1) * (0.9 + 0.2 * Math.random()),\r\n        armor: level,\r\n        damage: Math.floor((heroMaxLife / 10 + heroMaxLife / 10 * level / 100) * ((_c = definition.statFactors.damage) !== null && _c !== void 0 ? _c : 1)),\r\n        attacksPerSecond: (1 + 0.05 * level) * ((_d = definition.statFactors.attacksPerSecond) !== null && _d !== void 0 ? _d : 1),\r\n        attackCooldown: 0,\r\n        radius: definition.radius,\r\n        theta: 0,\r\n        minions: [],\r\n        chargingLevel: 1,\r\n        attackChargeLevel: 1,\r\n        mode: 'choose',\r\n        modeTime: 0,\r\n        setMode(mode) {\r\n            this.mode = mode;\r\n            this.modeTime = 0;\r\n        }\r\n    };\r\n}\r\nfunction shootEnemyBullet(state, enemy, vx, vy, stats = {}) {\r\n    //const mag = Math.sqrt(vx * vx + vy * vy);\r\n    state.enemyBullets.push({\r\n        //x: enemy.x + vx / mag * enemy.radius,\r\n        //y: enemy.y + vy / mag * enemy.radius,\r\n        x: enemy.x,\r\n        y: enemy.y,\r\n        damage: enemy.damage,\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_RADIUS,\r\n        vx,\r\n        vy,\r\n        expirationTime: state.fieldTime + app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ENEMY_BULLET_DURATION,\r\n        update: app_weapons__WEBPACK_IMPORTED_MODULE_2__.updateSimpleBullet,\r\n        hitTargets: new Set(),\r\n        ...stats,\r\n    });\r\n}\r\nfunction shootBulletArc(state, enemy, theta, angle, count, speed, stats = {}) {\r\n    for (let i = 0; i < count; i++) {\r\n        const bulletTheta = count > 1 ? (theta - angle / 2 + angle * i / (count - 1)) : theta;\r\n        shootEnemyBullet(state, enemy, speed * Math.cos(bulletTheta), speed * Math.sin(bulletTheta), stats);\r\n    }\r\n}\r\nfunction moveEnemyInCurrentDirection(state, enemy) {\r\n    enemy.x += enemy.speed * Math.cos(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    enemy.y += enemy.speed * Math.sin(enemy.theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\nfunction moveEnemyInDirection(state, enemy, theta = enemy.theta) {\r\n    enemy.x += enemy.speed * Math.cos(theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    enemy.y += enemy.speed * Math.sin(theta) / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\nfunction chaseTarget(state, enemy, target) {\r\n    const { x, y } = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.getTargetVector)(enemy, target);\r\n    enemy.theta = (0,app_utils_geometry__WEBPACK_IMPORTED_MODULE_1__.turnTowardsAngle)(enemy.theta, 0.2, Math.atan2(y, x));\r\n    moveEnemyInDirection(state, enemy);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/enemy.ts?");

/***/ }),

/***/ "./app/utils/geometry.ts":
/*!*******************************!*\
  !*** ./app/utils/geometry.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   doCirclesIntersect: () => (/* binding */ doCirclesIntersect),\n/* harmony export */   findClosestDisc: () => (/* binding */ findClosestDisc),\n/* harmony export */   getClosestElement: () => (/* binding */ getClosestElement),\n/* harmony export */   getTargetVector: () => (/* binding */ getTargetVector),\n/* harmony export */   turnTowardsAngle: () => (/* binding */ turnTowardsAngle)\n/* harmony export */ });\nfunction doCirclesIntersect(circleA, circleB) {\r\n    const radius = circleA.radius + circleB.radius;\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    return dx * dx + dy * dy < radius * radius;\r\n}\r\nfunction findClosestDisc({ x, y }, discs) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestDisc = discs[0];\r\n    for (const disc of discs) {\r\n        const dx = disc.x - x, dy = disc.y - y;\r\n        const distance2 = dx * dx + dy * dy - disc.radius * disc.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestDisc = disc;\r\n        }\r\n    }\r\n    return closestDisc;\r\n}\r\nfunction getClosestElement({ x, y }, elements) {\r\n    let closestDistance2 = Number.MAX_SAFE_INTEGER, closestElement = elements[0];\r\n    for (const element of elements) {\r\n        const dx = element.x - x, dy = element.y - y;\r\n        const distance2 = dx * dx + dy * dy - element.radius * element.radius;\r\n        if (distance2 < closestDistance2) {\r\n            closestDistance2 = distance2;\r\n            closestElement = element;\r\n        }\r\n    }\r\n    return closestElement;\r\n}\r\nfunction getTargetVector(circleA, circleB) {\r\n    const dx = circleB.x - circleA.x, dy = circleB.y - circleA.y;\r\n    const distance2 = dx * dx + dy * dy;\r\n    if (distance2 <= 0) {\r\n        return { x: 1, y: 0, distance2: 0 };\r\n    }\r\n    return { x: dx, y: dy, distance2 };\r\n}\r\nfunction turnTowardsAngle(theta, delta, targetTheta) {\r\n    const negativeDistance = (theta - targetTheta + 2 * Math.PI) % (2 * Math.PI);\r\n    const positiveDistance = (targetTheta - theta + 2 * Math.PI) % (2 * Math.PI);\r\n    if (negativeDistance <= delta || positiveDistance <= delta) {\r\n        return targetTheta;\r\n    }\r\n    if (negativeDistance < positiveDistance) {\r\n        return theta - delta;\r\n    }\r\n    return theta + delta;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/geometry.ts?");

/***/ }),

/***/ "./app/utils/hero.ts":
/*!***************************!*\
  !*** ./app/utils/hero.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gainExperience: () => (/* binding */ gainExperience),\n/* harmony export */   getExperienceForNextLevel: () => (/* binding */ getExperienceForNextLevel),\n/* harmony export */   refillAllPotions: () => (/* binding */ refillAllPotions),\n/* harmony export */   setDerivedHeroStats: () => (/* binding */ setDerivedHeroStats)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\r\nfunction gainExperience(state, experience) {\r\n    let requiredExperience = getExperienceForNextLevel(state.hero.level);\r\n    // You cannot gain more than 100% of the experience for the next level at once.\r\n    state.hero.experience += Math.min(experience, requiredExperience);\r\n    if (state.hero.experience >= requiredExperience) {\r\n        state.hero.level++;\r\n        state.hero.experience -= requiredExperience;\r\n        setDerivedHeroStats(state);\r\n        refillAllPotions(state);\r\n    }\r\n}\r\nfunction setDerivedHeroStats(state) {\r\n    state.hero.damage = Math.pow(1.05, state.hero.level - 1);\r\n    state.hero.attacksPerSecond = 1 + 0.01 * state.hero.level;\r\n    state.hero.maxLife = 20 * state.hero.level;\r\n    state.hero.life = state.hero.maxLife;\r\n}\r\nfunction getExperienceForNextLevel(currentLevel) {\r\n    const averageKills = 10 * currentLevel;\r\n    const xpPerKill = Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_XP * Math.pow(1.2, currentLevel - 1));\r\n    return averageKills * xpPerKill;\r\n}\r\nfunction refillAllPotions(state) {\r\n    state.hero.life = state.hero.maxLife;\r\n    state.hero.potions = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_MAX_POTIONS;\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/hero.ts?");

/***/ }),

/***/ "./app/utils/mouse.ts":
/*!****************************!*\
  !*** ./app/utils/mouse.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addContextMenuListeners: () => (/* binding */ addContextMenuListeners),\n/* harmony export */   bindMouseListeners: () => (/* binding */ bindMouseListeners),\n/* harmony export */   getMousePosition: () => (/* binding */ getMousePosition),\n/* harmony export */   isMouseDown: () => (/* binding */ isMouseDown),\n/* harmony export */   isMouseOverElement: () => (/* binding */ isMouseOverElement),\n/* harmony export */   isRightMouseDown: () => (/* binding */ isRightMouseDown)\n/* harmony export */ });\n/* harmony import */ var app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/utils/canvas */ \"./app/utils/canvas.ts\");\n/* harmony import */ var app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/utils/userInput */ \"./app/utils/userInput.ts\");\n//import { CANVAS_SCALE } from 'app/constants';\r\n\r\n\r\nlet mousePosition = [-1000, -1000];\r\nlet mouseIsDown = false;\r\nfunction isMouseDown() {\r\n    return mouseIsDown;\r\n}\r\nfunction getMousePosition(container = null, scale = 1) {\r\n    if (container) {\r\n        const containerRect = container.getBoundingClientRect();\r\n        return [\r\n            (mousePosition[0] - containerRect.x) / scale,\r\n            (mousePosition[1] - containerRect.y) / scale,\r\n        ];\r\n    }\r\n    return [mousePosition[0] / scale, mousePosition[1] / scale];\r\n}\r\nfunction onMouseMove(event) {\r\n    mousePosition = [event.pageX, event.pageY];\r\n    // console.log(mousePosition);\r\n}\r\nfunction onMouseDown(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = true;\r\n}\r\nfunction onMouseUp(event) {\r\n    if (event.which === 1)\r\n        mouseIsDown = false;\r\n}\r\nfunction bindMouseListeners() {\r\n    document.addEventListener('mousemove', onMouseMove);\r\n    document.addEventListener('mousedown', onMouseDown);\r\n    document.addEventListener('mouseup', onMouseUp);\r\n}\r\n/* This would in theory be used if we ever cleaned up the application\r\nexport function unbindMouseListeners() {\r\n    document.removeEventListener('mousemove', onMouseMove);\r\n    document.removeEventListener('mousedown', onMouseDown);\r\n    document.removeEventListener('mouseup', onMouseUp);\r\n    // Prevent mouse from being \"stuck down\"\r\n    mouseIsDown = false;\r\n}*/\r\nfunction isMouseOverElement(element) {\r\n    const rect = element.getBoundingClientRect();\r\n    return mousePosition[0] >= rect.x && mousePosition[0] <= rect.x + rect.width\r\n        && mousePosition[1] >= rect.y && mousePosition[1] <= rect.y + rect.height;\r\n}\r\n//let lastContextClick: number[];\r\nlet rightMouseIsDown = false;\r\nfunction isRightMouseDown() {\r\n    return rightMouseIsDown;\r\n}\r\nfunction addContextMenuListeners() {\r\n    document.addEventListener('mouseup', function (event) {\r\n        if (event.which === 3) {\r\n            rightMouseIsDown = false;\r\n            return;\r\n        }\r\n    });\r\n    document.addEventListener('mousedown', function (event) {\r\n        if (event.which === 3) {\r\n            rightMouseIsDown = true;\r\n            return;\r\n        }\r\n    });\r\n    // Prevent the context menu from displaying when clicking over the canvas unless shift is held.\r\n    app_utils_canvas__WEBPACK_IMPORTED_MODULE_0__.mainCanvas.addEventListener('contextmenu', function (event) {\r\n        if ((0,app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.isKeyboardKeyDown)(app_utils_userInput__WEBPACK_IMPORTED_MODULE_1__.KEY.SHIFT)) {\r\n            return;\r\n        }\r\n        event.preventDefault();\r\n        // const [x, y] = getMousePosition();\r\n        // lastContextClick = getMousePosition(mainCanvas, CANVAS_SCALE);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/mouse.ts?");

/***/ }),

/***/ "./app/utils/userInput.ts":
/*!********************************!*\
  !*** ./app/utils/userInput.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KEY: () => (/* binding */ KEY),\n/* harmony export */   addKeyboardListeners: () => (/* binding */ addKeyboardListeners),\n/* harmony export */   clearKeyboardState: () => (/* binding */ clearKeyboardState),\n/* harmony export */   isGameKeyDown: () => (/* binding */ isGameKeyDown),\n/* harmony export */   isKeyboardKeyDown: () => (/* binding */ isKeyboardKeyDown),\n/* harmony export */   updateKeyboardState: () => (/* binding */ updateKeyboardState),\n/* harmony export */   wasGameKeyPressed: () => (/* binding */ wasGameKeyPressed),\n/* harmony export */   wasGameKeyPressedAndReleased: () => (/* binding */ wasGameKeyPressedAndReleased)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\r\nconst KEY = {\r\n    ESCAPE: 27,\r\n    LEFT: 37,\r\n    RIGHT: 39,\r\n    UP: 38,\r\n    DOWN: 40,\r\n    SPACE: 32,\r\n    SHIFT: 16,\r\n    ENTER: 13,\r\n    BACK_SPACE: 8,\r\n    COMMAND: 91,\r\n    CONTROL: 17,\r\n    LEFT_BRACKET: 219,\r\n    BACK_SLASH: 220,\r\n    RIGHT_BRACKET: 221,\r\n    A: 'A'.charCodeAt(0),\r\n    C: 'C'.charCodeAt(0),\r\n    D: 'D'.charCodeAt(0),\r\n    E: 'E'.charCodeAt(0),\r\n    F: 'F'.charCodeAt(0),\r\n    G: 'G'.charCodeAt(0),\r\n    H: 'H'.charCodeAt(0),\r\n    I: 'I'.charCodeAt(0),\r\n    J: 'J'.charCodeAt(0),\r\n    K: 'K'.charCodeAt(0),\r\n    L: 'L'.charCodeAt(0),\r\n    M: 'M'.charCodeAt(0),\r\n    O: 'O'.charCodeAt(0),\r\n    P: 'P'.charCodeAt(0),\r\n    Q: 'Q'.charCodeAt(0),\r\n    R: 'R'.charCodeAt(0),\r\n    S: 'S'.charCodeAt(0),\r\n    T: 'T'.charCodeAt(0),\r\n    U: 'U'.charCodeAt(0),\r\n    V: 'V'.charCodeAt(0),\r\n    W: 'W'.charCodeAt(0),\r\n    X: 'X'.charCodeAt(0),\r\n    Y: 'Y'.charCodeAt(0),\r\n    Z: 'Z'.charCodeAt(0),\r\n};\r\nconst KEYBOARD_MAPPINGS = {\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.MENU]: [KEY.ENTER],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.UP]: [KEY.UP, KEY.W],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.DOWN]: [KEY.DOWN, KEY.S],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.LEFT]: [KEY.LEFT, KEY.A],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.RIGHT]: [KEY.RIGHT, KEY.D],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.ACTIVATE]: [KEY.SPACE],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.SELL]: [KEY.X],\r\n    [app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY.POTION]: [KEY.F],\r\n};\r\nconst ANALOG_THRESHOLD = 0.3;\r\nconst keysDown = [];\r\nfunction isKeyboardKeyDown(keyCode) {\r\n    if (keysDown[keyCode]) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}\r\nfunction addKeyboardListeners() {\r\n    document.addEventListener('keyup', function (event) {\r\n        const keyCode = event.which;\r\n        keysDown[keyCode] = 0;\r\n    });\r\n    document.addEventListener('keydown', function (event) {\r\n        if (event.repeat) {\r\n            return;\r\n        }\r\n        // Don't process keys if an input is targeted, otherwise we prevent typing in\r\n        // the input.\r\n        if (event.target.closest('input')\r\n            || event.target.closest('textarea')\r\n            || event.target.closest('select')) {\r\n            return;\r\n        }\r\n        const commandIsDown = (keysDown[KEY.CONTROL] || keysDown[KEY.COMMAND]);\r\n        const keyCode = event.which;\r\n        //console.log(keyCode);\r\n        // Don't override the refresh page command.\r\n        if (keyCode === KEY.R && commandIsDown) {\r\n            return;\r\n        }\r\n        keysDown[keyCode] = 1;\r\n    });\r\n}\r\nfunction updateKeyboardState(state) {\r\n    const previousGameKeysDown = state.keyboard.gameKeysDown;\r\n    // This set is persisted until a new set of keys is pressed.\r\n    let mostRecentKeysPressed = state.keyboard.mostRecentKeysPressed;\r\n    const gameKeyValues = [];\r\n    const gameKeysDown = new Set();\r\n    const gameKeysPressed = new Set();\r\n    const gameKeysReleased = new Set();\r\n    /*for (const gameKey of GAME_PAD_AXIS_MAPPINGS) {\r\n\r\n    }*/\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n        for (const keyboardCode of (KEYBOARD_MAPPINGS[gameKey] || [])) {\r\n            gameKeyValues[gameKey] = isKeyboardKeyDown(keyboardCode);\r\n            if (gameKeyValues[gameKey]) {\r\n                break;\r\n            }\r\n        }\r\n        if (gameKeyValues[gameKey] >= ANALOG_THRESHOLD) {\r\n            gameKeysDown.add(gameKey);\r\n        }\r\n    }\r\n    for (const oldKeyDown of [...previousGameKeysDown]) {\r\n        if (!gameKeysDown.has(oldKeyDown)) {\r\n            gameKeysReleased.add(oldKeyDown);\r\n        }\r\n    }\r\n    for (const newKeyDown of [...gameKeysDown]) {\r\n        if (!previousGameKeysDown.has(newKeyDown)) {\r\n            gameKeysPressed.add(newKeyDown);\r\n        }\r\n    }\r\n    if (gameKeysPressed.size > 0) {\r\n        mostRecentKeysPressed = gameKeysPressed;\r\n    }\r\n    state.keyboard = { gameKeyValues, gameKeysDown, gameKeysPressed, gameKeysReleased, mostRecentKeysPressed };\r\n}\r\nfunction clearKeyboardState(state) {\r\n    const gameKeyValues = [];\r\n    for (let gameKey of Object.values(app_constants__WEBPACK_IMPORTED_MODULE_0__.GAME_KEY)) {\r\n        gameKeyValues[gameKey] = 0;\r\n    }\r\n    state.keyboard = {\r\n        gameKeyValues,\r\n        gameKeysDown: new Set(),\r\n        gameKeysPressed: new Set(),\r\n        gameKeysReleased: new Set(),\r\n        mostRecentKeysPressed: new Set(),\r\n    };\r\n}\r\nfunction wasGameKeyPressed(state, keyCode) {\r\n    return state.keyboard.gameKeysPressed.has(keyCode);\r\n}\r\n// Only returns true if a key was pressed and released without any other keys having been pressed in between.\r\n// Specifically this is used to determined whether to switch clones, which should only happen if the user presses\r\n// the clone tool button without pressing any other buttons before releasing it. Note that it is okay if they\r\n// continue holding buttons that were already down when pressing the clone button.\r\nfunction wasGameKeyPressedAndReleased(state, keyCode) {\r\n    return state.keyboard.mostRecentKeysPressed.has(keyCode) && state.keyboard.gameKeysReleased.has(keyCode);\r\n}\r\nfunction isGameKeyDown(state, keyCode) {\r\n    return state.keyboard.gameKeysDown.has(keyCode);\r\n}\r\n\n\n//# sourceURL=webpack://alttp/./app/utils/userInput.ts?");

/***/ }),

/***/ "./app/weapons.ts":
/*!************************!*\
  !*** ./app/weapons.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   allWeapons: () => (/* binding */ allWeapons),\n/* harmony export */   bows: () => (/* binding */ bows),\n/* harmony export */   daggers: () => (/* binding */ daggers),\n/* harmony export */   swords: () => (/* binding */ swords),\n/* harmony export */   updateSimpleBullet: () => (/* binding */ updateSimpleBullet)\n/* harmony export */ });\n/* harmony import */ var app_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! app/constants */ \"./app/constants.ts\");\n\r\nfunction updateSimpleBullet(state, bullet) {\r\n    bullet.x += bullet.vx / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n    bullet.y += bullet.vy / app_constants__WEBPACK_IMPORTED_MODULE_0__.FRAME_LENGTH;\r\n}\r\n/*\r\nExample damage spread for weapon tiers:\r\n0: 20\r\n1: 35\r\n2: 60\r\n3: 100\r\n4: 150\r\n5: 230\r\n6: 350\r\n7: 500\r\n8: 700\r\n9: 950\r\n10: 1250\r\n11: 1550\r\n12: 1850\r\n13: 2000\r\n*/\r\nconst bowShots = [\r\n    {\r\n        generateBullet(state, source, weapon) {\r\n            const speed = weapon.speed * (0.6 + 0.4 * source.attackChargeLevel);\r\n            return {\r\n                x: source.x,\r\n                y: source.y,\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n                vx: speed * Math.cos(source.theta),\r\n                vy: speed * Math.sin(source.theta),\r\n                damage: Math.ceil(weapon.damage * source.attackChargeLevel * source.damage),\r\n                isEnemyPiercing: true,\r\n                source,\r\n                expirationTime: state.fieldTime + weapon.duration,\r\n                update: updateSimpleBullet,\r\n                hitTargets: new Set(),\r\n            };\r\n        },\r\n    }\r\n];\r\nfunction createBow(level, name) {\r\n    const attacksPerSecond = app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND * 0.8;\r\n    return {\r\n        type: 'bow',\r\n        level: Math.floor(level),\r\n        name,\r\n        shots: bowShots,\r\n        attacksPerSecond,\r\n        damage: Math.ceil(0.8 * level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / attacksPerSecond),\r\n        chargeLevel: 3,\r\n        speed: 1.5 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED,\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS,\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n    };\r\n}\r\nconst bows = [\r\n    createBow(1, 'Primitive Bow'),\r\n    createBow(1.75, 'Short Bow'),\r\n    createBow(3, 'Recurve Bow'),\r\n    createBow(5, 'Long Bow'),\r\n];\r\nconst swordShots = [\r\n    {\r\n        generateBullet(state, source, weapon) {\r\n            return {\r\n                x: source.x,\r\n                y: source.y,\r\n                radius: weapon.radius * source.attackChargeLevel,\r\n                vx: weapon.speed * Math.cos(source.theta),\r\n                vy: weapon.speed * Math.sin(source.theta),\r\n                damage: Math.ceil(weapon.damage * source.attackChargeLevel * source.damage),\r\n                isEnemyPiercing: (source.attackChargeLevel >= 2),\r\n                source,\r\n                expirationTime: state.fieldTime + weapon.duration,\r\n                update: updateSimpleBullet,\r\n                hitTargets: new Set(),\r\n            };\r\n        },\r\n    }\r\n];\r\nfunction createSword(level, name) {\r\n    return {\r\n        type: 'sword',\r\n        level,\r\n        name,\r\n        shots: swordShots,\r\n        attacksPerSecond: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND,\r\n        damage: Math.ceil(level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND),\r\n        chargeLevel: 2,\r\n        speed: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED,\r\n        radius: Math.ceil(1.2 * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS),\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n    };\r\n}\r\nconst swords = [\r\n    createSword(1, 'Gladius'),\r\n    createSword(2, 'Short Sword'),\r\n    createSword(4, 'Falchion'),\r\n    createSword(6, 'Scimitar'),\r\n];\r\nfunction generateDaggerShot(timingOffset, thetaOffset) {\r\n    return {\r\n        timingOffset,\r\n        generateBullet(state, source, weapon) {\r\n            return {\r\n                x: source.x,\r\n                y: source.y,\r\n                vx: weapon.speed * Math.cos(source.theta + thetaOffset / source.attackChargeLevel),\r\n                vy: weapon.speed * Math.sin(source.theta + thetaOffset / source.attackChargeLevel),\r\n                damage: Math.ceil(weapon.damage * source.attackChargeLevel * source.damage),\r\n                radius: weapon.radius + (source.attackChargeLevel - 1),\r\n                source,\r\n                expirationTime: state.fieldTime + weapon.duration,\r\n                update: updateSimpleBullet,\r\n                hitTargets: new Set(),\r\n            };\r\n        },\r\n    };\r\n}\r\nconst daggerShots = [\r\n    generateDaggerShot(0 / 7, 0),\r\n    generateDaggerShot(1 / 7, Math.PI / 18),\r\n    generateDaggerShot(2 / 7, -Math.PI / 18),\r\n    generateDaggerShot(3 / 7, 2 * Math.PI / 18),\r\n    generateDaggerShot(4 / 7, -2 * Math.PI / 18),\r\n    generateDaggerShot(5 / 7, 3 * Math.PI / 18),\r\n    generateDaggerShot(6 / 7, -3 * Math.PI / 18),\r\n];\r\nfunction createDagger(level, name) {\r\n    return {\r\n        type: 'dagger',\r\n        level: Math.floor(level),\r\n        name,\r\n        shots: daggerShots,\r\n        attacksPerSecond: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND,\r\n        damage: Math.ceil(0.2 * level * app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_WEAPON_DPS_PER_LEVEL / app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_ATTACKS_PER_SECOND),\r\n        chargeLevel: 2,\r\n        speed: Math.ceil(app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_SPEED * 0.7),\r\n        radius: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_RADIUS,\r\n        duration: app_constants__WEBPACK_IMPORTED_MODULE_0__.BASE_BULLET_DURATION,\r\n    };\r\n}\r\nconst daggers = [\r\n    createDagger(1.5, 'Pugio'),\r\n    createDagger(3, 'Hewing Knife'),\r\n    createDagger(5, 'Cross-hilt Dagger'),\r\n    createDagger(7, 'Tanto'),\r\n];\r\nconst allWeapons = [\r\n    swords,\r\n    bows,\r\n    daggers,\r\n];\r\n// TODO: Add katanas, 2 parallel bullets offset by 50% and centers 12px apart. 60% damage\r\n// TODO: Add morning star, shot spins around the source and loops at the attack speed interval, pierces enemies\r\n//       2 Charge levels increases radius by 16px each\r\n// TODO: Add staff, single piercing shot that gets bigger but weaker with distance 120% damage at close range, down to 20% at max range\r\n//       Add rendering function to bullets so we can make the staff shot fade as it gets weaker.\r\n\n\n//# sourceURL=webpack://alttp/./app/weapons.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/client.ts");
/******/ 	
/******/ })()
;